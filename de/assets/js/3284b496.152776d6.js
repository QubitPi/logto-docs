"use strict";(self.webpackChunk_logto_docs=self.webpackChunk_logto_docs||[]).push([[9023],{66086:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>g,frontMatter:()=>d,metadata:()=>t,toc:()=>u});const t=JSON.parse('{"id":"end-user-flows/sign-out","title":"Abmelden","description":"Der Abmeldeprozess in Logto (als OIDC-basierter Identit\xe4tsanbieter) ist ein vielschichtiges Konzept, da sowohl die zentralisierte Anmeldesitzung, die von Logto verwaltet wird, als auch der verteilte Authentifizierungsstatus, der von den Client-Anwendungen verwaltet wird, beteiligt sind.","source":"@site/i18n/de/docusaurus-plugin-content-docs/current/end-user-flows/sign-out.mdx","sourceDirName":"end-user-flows","slug":"/end-user-flows/sign-out","permalink":"/de/end-user-flows/sign-out","draft":false,"unlisted":false,"editUrl":"https://github.com/logto-io/docs/tree/master/i18n/de/docusaurus-plugin-content-docs/current/end-user-flows/sign-out.mdx","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"docsSidebar","previous":{"title":"Zustimmungsbildschirm (Consent screen)","permalink":"/de/end-user-flows/consent-screen"},"next":{"title":"Kontoeinstellungen","permalink":"/de/end-user-flows/account-settings/"}}');var r=i(25105),s=i(79621);const d={sidebar_position:6},l="Abmelden",o={},u=[{value:"Anmeldesitzung",id:"sign-in-session",level:2},{value:"Komponenten",id:"components",level:2},{value:"Zentralisierte Anmeldesitzung, verwaltet von Logto",id:"centralized-sign-in-session-managed-by-logto",level:3},{value:"Verteilter Authentifizierungsstatus, verwaltet von den Client-Anwendungen",id:"distributed-authentication-status-managed-by-the-client-applications",level:2},{value:"Abmeldemechanismen",id:"sign-out-mechanisms",level:2},{value:"Tokens und lokale Sitzung auf Client-Seite l\xf6schen",id:"clear-tokens-and-local-session-at-the-client-side",level:3},{value:"Anmeldesitzung bei Logto l\xf6schen",id:"clear-sign-in-session-at-logto",level:3},{value:"F\xf6derierte Abmeldung: Back-Channel-Logout",id:"federated-sign-out-back-channel-logout",level:2},{value:"Abmeldemethoden in Logto SDKs",id:"sign-out-methods-in-logto-sdks",level:2},{value:"Erzwinge erneute Authentifizierung bei jedem Zugriff",id:"enforce-re-authentication-on-every-access",level:2},{value:"FAQs",id:"faqs",level:2},{value:"Ich erhalte keine Back-Channel-Logout-Benachrichtigungen.",id:"im-not-receiving-the-back-channel-logout-notifications",level:3},{value:"Verwandte Ressourcen",id:"related-resources",level:2}];function a(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components},{Details:i,Url:t}=n;return i||c("Details",!0),t||c("Url",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"abmelden",children:"Abmelden"})}),"\n",(0,r.jsx)(n.p,{children:"Der Abmeldeprozess in Logto (als OIDC-basierter Identit\xe4tsanbieter) ist ein vielschichtiges Konzept, da sowohl die zentralisierte Anmeldesitzung, die von Logto verwaltet wird, als auch der verteilte Authentifizierungsstatus, der von den Client-Anwendungen verwaltet wird, beteiligt sind."}),"\n",(0,r.jsx)(n.h2,{id:"sign-in-session",children:"Anmeldesitzung"}),"\n",(0,r.jsx)(n.p,{children:"Um den Abmeldeprozess besser zu verstehen, ist es wichtig, zun\xe4chst zu verstehen, wie Benutzersitzungen und deren Authentifizierungsstatus in Logto verwaltet werden."}),"\n",(0,r.jsx)(n.mermaid,{value:"  sequenceDiagram\n    autonumber\n    actor Benutzer\n\n    box Vertrauende Partei (RP)\n      participant Client as Client-Anwendung\n    end\n\n    box Logto (IdP)\n      participant OIDC as OIDC-Anbieter\n      participant SignIn as Anmeldeseite\n    end\n\n    Benutzer ->> Client: Greift auf Webanwendung zu\n    Client ->> OIDC: Leitet Benutzer zur Authentifizierung an OIDC weiter\n    OIDC --\x3e> OIDC: \xdcberpr\xfcft Anmeldesitzung des Benutzers\n    OIDC ->> SignIn: Fordert Benutzer zur Anmeldung auf\n    SignIn ->> OIDC: Identifiziert Benutzer und \xfcbermittelt das Interaktionsergebnis\n    OIDC --\x3e> OIDC: Erstellt Anmeldesitzung und Authentifizierungsberechtigung f\xfcr den Benutzer\n    OIDC ->> Client: Leitet Benutzer mit Authentifizierungscode zur\xfcck zur Webanwendung (Authorization Code Flow)\n    Client ->> OIDC: Tauscht den Code gegen Tokens aus\n    OIDC --\x3e> Client: Gibt Tokens zur\xfcck"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Der Benutzer greift auf die Webanwendung (RP) zu."}),"\n",(0,r.jsxs)(n.li,{children:["Die Client-Anwendung leitet den Benutzer zu Logto (IdP) zur ",(0,r.jsx)(n.a,{href:"https://auth.wiki/authentication",children:"Authentifizierung (Authentication)"})," weiter."]}),"\n",(0,r.jsx)(n.li,{children:"Der OIDC-Anbieter pr\xfcft den Status der Anmeldesitzung des Benutzers. Falls keine Sitzung existiert oder die Sitzung abgelaufen ist, wird der Benutzer zur Anmeldung aufgefordert."}),"\n",(0,r.jsx)(n.li,{children:"Der Benutzer interagiert mit der Anmeldeseite, um sich zu authentifizieren."}),"\n",(0,r.jsx)(n.li,{children:"Nach erfolgreicher Anmeldung erstellt Logto eine neue Sitzung f\xfcr den Benutzer und leitet mit einem Autorisierungscode zur\xfcck zur Client-Anwendung."}),"\n",(0,r.jsx)(n.li,{children:"Der OIDC-Anbieter erstellt eine neue Anmeldesitzung und Authentifizierungsberechtigung f\xfcr den Benutzer."}),"\n",(0,r.jsxs)(n.li,{children:["Der OIDC-Anbieter leitet den Benutzer mit einem Authentifizierungscode (",(0,r.jsx)(n.a,{href:"https://auth.wiki/authorization-code-flow",children:"Authorization Code Flow"}),") zur\xfcck zum Client."]}),"\n",(0,r.jsx)(n.li,{children:"Der Client erh\xe4lt den Authentifizierungscode und tauscht ihn gegen Tokens aus, um Benutzerinformationen zu erhalten."}),"\n",(0,r.jsx)(n.li,{children:"Tokens werden an die Client-Anwendung ausgegeben."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"components",children:"Komponenten"}),"\n",(0,r.jsx)(n.h3,{id:"centralized-sign-in-session-managed-by-logto",children:"Zentralisierte Anmeldesitzung, verwaltet von Logto"}),"\n",(0,r.jsx)(n.p,{children:"Im obigen Ablauf wird die zentralisierte Anmeldesitzung von Logto verwaltet. Die Sitzung wird erstellt, wenn sich der Benutzer erfolgreich anmeldet, und zerst\xf6rt, wenn sich der Benutzer abmeldet. Die Sitzung wird ebenfalls zerst\xf6rt, wenn die Sitzung des Benutzers abl\xe4uft."}),"\n",(0,r.jsx)(n.p,{children:"Die Logto-Anmeldesitzung wird mit Session-Cookies verwaltet. Das Session-Cookie wird gesetzt, wenn sich der Benutzer anmeldet. Alle Authentifizierungsanfragen werden gegen das Session-Cookie validiert. Ist das Session-Cookie vorhanden und g\xfcltig, wird der Benutzer automatisch authentifiziert und direkt mit dem Autorisierungscode zur Client-Anwendung weitergeleitet. Andernfalls wird der Benutzer zur Anmeldung aufgefordert."}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Geteiltes Logto-Session-Cookie",(0,r.jsx)(n.br,{}),"\n","F\xfcr einen Benutzer, der sich von demselben User-Agent (z. B. Browser) bei mehreren Client-Anwendungen anmeldet, gibt es ein geteiltes Session-Cookie unter der Logto-Domain. Das bedeutet, dass sich der Benutzer nur einmal anmelden muss und automatisch f\xfcr andere Client-Anwendungen authentifiziert wird."]}),"\n",(0,r.jsx)(n.mermaid,{value:" flowchart TD\n subgraph Benutzer [User Agent A]\n   U[Benutzer]\n\n   subgraph Layer1 [Client-Domain A]\n     A[Client-Anwendung A]\n   end\n\n   subgraph Layer1 [Client-Domain B]\n     B[Client-Anwendung B]\n   end\n\n   subgraph Layer2 [Logto-Domain]\n       C{{Logto-Anmeldesitzung?}}\n       D[Anmeldeseite]\n   end\n end\n\n U --\x3e |Anmelden| A\n A --\x3e |Weiterleitung zu Logto| C\n U --\x3e |Anmelden| B\n B --\x3e |Weiterleitung zu Logto| C\n C --\x3e |Nein| D\n D --\x3e |Sitzung erstellen| C"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Isoliertes Logto-Session-Cookie",(0,r.jsx)(n.br,{}),"\n","F\xfcr einen Benutzer, der sich von verschiedenen Ger\xe4ten oder Browsern bei unterschiedlichen Client-Anwendungen anmeldet, gibt es isolierte Session-Cookies unter der Logto-Domain. Das bedeutet, dass sich der Benutzer f\xfcr jede Client-Anwendung separat anmelden muss."]}),"\n",(0,r.jsx)(n.mermaid,{value:" flowchart TD\n U[Benutzer]\n\n subgraph DeviceA [User Agent A]\n   subgraph Layer1 [Client-Domain A]\n     A[Client-Anwendung A]\n   end\n\n   subgraph Layer2 [Logto-Domain]\n       C{{Logto-Anmeldesitzung?}}\n       D[Anmeldeseite]\n   end\n end\n\n subgraph DeviceB [User Agent B]\n   subgraph Layer3 [Client-Domain B]\n     B[Client-Anwendung B]\n   end\n\n   subgraph Layer4 [Logto-Domain]\n       E{{Logto-Anmeldesitzung?}}\n       F[Anmeldeseite]\n   end\n end\n\n U --\x3e |Anmelden| A\n A --\x3e |Weiterleitung zu Logto| C\n U --\x3e |Anmelden| B\n B --\x3e |Weiterleitung zu Logto| E\n C --\x3e |Nein| D\n E --\x3e |Nein| F\n D --\x3e |Sitzung erstellen| C\n F --\x3e |Sitzung erstellen| E"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"distributed-authentication-status-managed-by-the-client-applications",children:"Verteilter Authentifizierungsstatus, verwaltet von den Client-Anwendungen"}),"\n",(0,r.jsx)(n.p,{children:"Jede Client-Anwendung verwaltet ihren eigenen Authentifizierungsstatus. Egal ob Native-, SPA- oder Webanwendung \u2013 alle haben ihre eigene Methode, den Authentifizierungsstatus des Benutzers zu verwalten."}),"\n",(0,r.jsxs)(n.p,{children:["Nach erfolgreicher Anmeldung kann die Client-Anwendung ein ",(0,r.jsx)(n.a,{href:"https://auth.wiki/id-token",children:"ID-Token"})," und ein ",(0,r.jsx)(n.a,{href:"https://auth.wiki/access-token",children:"Zugangstoken (Access token)"})," erhalten. Die Client-Anwendung kann das ID-Token verwenden, um die Identit\xe4t des Benutzers zu bestimmen, und das Zugangstoken, um auf die Ressourcen des Benutzers zuzugreifen. Der Authentifizierungsstatus des Benutzers wird durch die Ablaufzeit des Zugangstokens repr\xe4sentiert."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Native- und SPA-Anwendungen:",(0,r.jsx)(n.br,{}),"\n","Die Client-Anwendung muss diese Tokens sicher speichern und verwalten, um den Authentifizierungsstatus des Benutzers aufrechtzuerhalten. Zum Beispiel k\xf6nnen die Tokens im Local Storage oder Session Storage gespeichert und beim Abmelden gel\xf6scht werden."]}),"\n",(0,r.jsxs)(n.li,{children:["Webanwendungen:",(0,r.jsx)(n.br,{}),"\n","Webanwendungen, wie sie mit Frameworks wie Next.js gebaut werden, verwalten oft ihre eigene Sitzung f\xfcr angemeldete Benutzer zus\xe4tzlich zu den von Logto ausgegebenen Tokens. Nach der Anmeldung und dem Empfang der Tokens von Logto kann die Webanwendung die Tokens clientseitig wie SPA-Anwendungen speichern oder serverseitig speichern und die Sitzung mit Cookies oder anderen Mechanismen verwalten."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"sign-out-mechanisms",children:"Abmeldemechanismen"}),"\n",(0,r.jsx)(n.h3,{id:"clear-tokens-and-local-session-at-the-client-side",children:"Tokens und lokale Sitzung auf Client-Seite l\xf6schen"}),"\n",(0,r.jsx)(n.p,{children:"Auf der Client-Seite beinhaltet eine einfache Abmeldung das L\xf6schen der lokalen Sitzung und das Entfernen der Tokens (ID-Token, Zugangstoken, Auffrischungstoken) aus dem Local Storage oder Session Storage. Dies f\xfchrt zu einer reinen Client-seitigen Abmeldung, bei der die zentralisierte Sitzung bestehen bleibt. Benutzer, die sich auf diese Weise abmelden, k\xf6nnen m\xf6glicherweise weiterhin auf andere Anwendungen unter derselben Autorisierungsserver-Sitzung zugreifen, bis die zentralisierte Sitzung abl\xe4uft oder aktiv zerst\xf6rt wird."}),"\n",(0,r.jsx)(n.h3,{id:"clear-sign-in-session-at-logto",children:"Anmeldesitzung bei Logto l\xf6schen"}),"\n",(0,r.jsxs)(n.p,{children:["Um den Benutzer explizit abzumelden und die Sitzung bei Logto zu l\xf6schen, muss die Client-Anwendung den Benutzer zum ",(0,r.jsx)(n.strong,{children:"End-Session-Endpunkt"})," von Logto weiterleiten."]}),"\n",(0,r.jsxs)(n.p,{children:["Z. B. ",(0,r.jsx)(n.code,{children:"https://{your-logto-domain}/oidc/session/end"})]}),"\n",(0,r.jsxs)(n.p,{children:["Der ",(0,r.jsx)(n.strong,{children:"End-Session-Endpunkt"})," ist ein standardisierter OIDC-Endpunkt, der es der Client-Anwendung erm\xf6glicht, dem Autorisierungsserver mitzuteilen, dass sich der Benutzer abgemeldet hat. Der Endpunkt l\xf6scht die zentralisierte Anmeldesitzung bei Logto."]}),"\n",(0,r.jsx)(n.p,{children:"Sobald die Sitzung gel\xf6scht ist, erfordern alle nachfolgenden Autorisierungsanfragen, dass sich der Benutzer erneut anmeldet."}),"\n",(0,r.jsxs)(n.p,{children:["Wenn eine ",(0,r.jsx)(n.strong,{children:"Post-Logout-Redirect-URI"})," angegeben wird, wird der Benutzer nach dem L\xf6schen der Sitzung zur angegebenen URI weitergeleitet. Andernfalls wird der Benutzer auf die Standard-Post-Logout-Seite von Logto weitergeleitet."]}),"\n",(0,r.jsx)(n.h2,{id:"federated-sign-out-back-channel-logout",children:"F\xf6derierte Abmeldung: Back-Channel-Logout"}),"\n",(0,r.jsxs)(n.p,{children:["F\xfcr ein konsistenteres Abmeldemanagement unterst\xfctzt Logto ",(0,r.jsx)(n.a,{href:"https://openid.net/specs/openid-connect-backchannel-1_0-final.html",children:"Back-Channel-Logout"}),". Back-Channel-Logout ist ein Mechanismus, der es Logto erm\xf6glicht, alle Client-Anwendungen unter derselben Anmeldesitzung zu benachrichtigen, wenn sich der Benutzer abmeldet."]}),"\n",(0,r.jsx)(n.p,{children:"Dies ist besonders n\xfctzlich in Szenarien, in denen sich der Benutzer von einer Client-Anwendung abmeldet und erwartet, dass er auch bei allen anderen Client-Anwendungen unter derselben Logto-Anmeldesitzung abgemeldet wird."}),"\n",(0,r.jsx)(n.p,{children:"Um Back-Channel-Logout f\xfcr deine Client-Anwendungen zu aktivieren, gehe auf die Anwendungsdetailseite im Logto-Dashboard und registriere eine Back-Channel-Logout-URI. Logto sendet ein Logout-Token an alle registrierten URIs, wenn der Benutzer eine Abmeldeanfrage von einer beliebigen Client-Anwendung ausl\xf6st."}),"\n",(0,r.jsxs)(n.p,{children:["Wenn deine Client-Anwendung erfordert, dass die Anmeldesitzung im Logout-Token enthalten ist, aktiviere die Einstellung ",(0,r.jsx)(n.code,{children:"Is session required"})," in der Back-Channel-Logout-Konfiguration. Ein ",(0,r.jsx)(n.code,{children:"sid"}),"-Anspruch wird dann im Logout-Token enthalten sein, um die Anmeldesitzung des Benutzers bei Logto zu identifizieren."]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Der Benutzer initiiert eine Abmeldeanfrage von einer Client-Anwendung."}),"\n",(0,r.jsx)(n.li,{children:"Logto erh\xe4lt die End-Session-Anfrage, generiert ein Logout-Token und sendet das Logout-Token an alle registrierten Back-Channel-Logout-URIs."}),"\n",(0,r.jsx)(n.li,{children:"Jede Client-Anwendung empf\xe4ngt das Logout-Token und f\xfchrt Abmeldeaktionen durch."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Abmeldeaktionen f\xfcr jede Client-Anwendung beim Empfang des Logout-Tokens:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Das Logout-Token validieren."}),"\n",(0,r.jsx)(n.li,{children:"Die lokale Sitzung l\xf6schen und Tokens aus Local Storage oder Session Storage entfernen."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"sign-out-methods-in-logto-sdks",children:"Abmeldemethoden in Logto SDKs"}),"\n",(0,r.jsx)(n.p,{children:"Wenn du Logto mit deiner Client-Anwendung \xfcber die Logto-SDKs integrierst:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["F\xfcr SPA- und Webanwendungen l\xf6scht die Methode ",(0,r.jsx)(n.code,{children:"client.signOut()"})," den lokalen Token-Speicher und leitet den Benutzer zum End-Session-Endpunkt von Logto weiter. Du kannst eine ",(0,r.jsx)(n.strong,{children:"Post-Logout-Redirect-URI"})," angeben, um den Benutzer nach dem L\xf6schen der Sitzung weiterzuleiten."]}),"\n",(0,r.jsxs)(n.li,{children:["F\xfcr native Anwendungen (einschlie\xdflich hybrider Apps wie ",(0,r.jsx)(n.strong,{children:"React Native"})," und ",(0,r.jsx)(n.strong,{children:"Flutter"}),") wird nur der lokale Token-Speicher gel\xf6scht. Das liegt daran, dass in nativen Anwendungen der Anmeldeprozess \xfcber eine sessionlose Webview abgewickelt wird. Es werden keine Session-Cookies im nativen Browser gespeichert, daher muss die Anmeldesitzung bei Logto nicht gel\xf6scht werden. Jede Authentifizierungsanfrage ist eine eigenst\xe4ndige Anfrage, die keine Session-Cookies \xfcbertr\xe4gt."]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["F\xfcr native Anwendungen, die keine sessionlose Webview unterst\xfctzen oder die ",(0,r.jsx)(n.code,{children:"emphasized"}),"-Einstellungen nicht erkennen (Android-App mit ",(0,r.jsx)(n.strong,{children:"React Native"})," oder ",(0,r.jsx)(n.strong,{children:"Flutter"})," SDK), kannst du den Benutzer zwingen, sich erneut anzumelden, indem du den Parameter ",(0,r.jsx)(n.code,{children:"prompt=login"})," in der Autorisierungsanfrage \xfcbergibst."]})}),"\n",(0,r.jsx)(n.h2,{id:"enforce-re-authentication-on-every-access",children:"Erzwinge erneute Authentifizierung bei jedem Zugriff"}),"\n",(0,r.jsxs)(n.p,{children:["In Hochsicherheits-Szenarien \u2013 wie der \xdcberpr\xfcfung der Identit\xe4t eines Benutzers vor sensiblen Aktionen \u2013 m\xf6chtest du m\xf6glicherweise verlangen, dass sich der Benutzer bei jedem Zugriff erneut authentifiziert. Um dieses Verhalten zu erzwingen, f\xfcge ",(0,r.jsx)(n.code,{children:"prompt=login"})," in deine Authentifizierungsanfrage ein."]}),"\n",(0,r.jsxs)(n.p,{children:["Das Setzen von ",(0,r.jsx)(n.code,{children:"prompt=login"})," zwingt Logto dazu, immer die Anmeldeseite anzuzeigen, unabh\xe4ngig davon, ob der Benutzer eine aktive Sitzung hat oder sich k\xfcrzlich angemeldet hat. Dies umgeht das Single Sign-On (SSO)-Verhalten und stellt sicher, dass der Benutzer jedes Mal zur Eingabe seiner Zugangsdaten aufgefordert wird."]}),"\n",(0,r.jsxs)(n.p,{children:["Wenn deine App den Scope offline_access (um ein Auffrischungstoken zu erhalten) anfordert, verlangt die OpenID Connect-Spezifikation, dass du auch ",(0,r.jsx)(n.code,{children:"prompt=consent"})," einschlie\xdft.",(0,r.jsx)(n.br,{}),"\n","In den meisten F\xe4llen, um sowohl die erneute Authentifizierung zu erzwingen als auch die Ausgabe eines Auffrischungstokens sicherzustellen, setze:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"prompt=login consent\n"})}),"\n",(0,r.jsx)(n.p,{children:"Dies garantiert, dass der Benutzer erneut authentifiziert wird und ausdr\xfccklich dem Offline-Zugriff zustimmt."}),"\n",(0,r.jsx)(n.h2,{id:"faqs",children:"FAQs"}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsx)("summary",{children:(0,r.jsx)(n.h3,{id:"im-not-receiving-the-back-channel-logout-notifications",children:"Ich erhalte keine Back-Channel-Logout-Benachrichtigungen."})}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Stelle sicher, dass die Back-Channel-Logout-URI korrekt im Logto-Dashboard registriert ist."}),"\n",(0,r.jsx)(n.li,{children:"Stelle sicher, dass deine Client-Anwendung eine g\xfcltige aktive Anmeldesitzung hat und es sich um dieselbe Sitzung handelt, die die Abmeldeanfrage initiiert hat."}),"\n"]})]}),"\n",(0,r.jsx)(n.h2,{id:"related-resources",children:"Verwandte Ressourcen"}),"\n",(0,r.jsx)(t,{href:"https://blog.logto.io/oidc-back-channel-logout/",children:(0,r.jsx)(n.p,{children:"OIDC Back-Channel-Logout verstehen."})})]})}function g(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}function c(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},79621:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>l});var t=i(58101);const r={},s=t.createContext(r);function d(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);