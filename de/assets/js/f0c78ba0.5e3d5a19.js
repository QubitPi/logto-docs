"use strict";(self.webpackChunk_logto_docs=self.webpackChunk_logto_docs||[]).push([[8114],{88312:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>Ae,contentTitle:()=>je,default:()=>ye,frontMatter:()=>xe,metadata:()=>r,toc:()=>we});const r=JSON.parse('{"id":"authorization/validate-access-tokens/README","title":"Wie du Zugangstokens in deinem API-Dienst oder Backend validierst","description":"Die Validierung von Zugangstokens ist ein entscheidender Bestandteil der Durchsetzung der rollenbasierten Zugangskontrolle (RBAC) in Logto. Diese Anleitung f\xfchrt dich durch die \xdcberpr\xfcfung von von Logto ausgestellten JWTs in deinem Backend / API, einschlie\xdflich der Pr\xfcfung von Signatur, Aussteller (Issuer), Zielgruppe (Audience), Ablauf, Berechtigungen (Scopes) und Organisationskontext.","source":"@site/i18n/de/docusaurus-plugin-content-docs/current/authorization/validate-access-tokens/README.mdx","sourceDirName":"authorization/validate-access-tokens","slug":"/authorization/validate-access-tokens/","permalink":"/de/authorization/validate-access-tokens/","draft":false,"unlisted":false,"editUrl":"https://github.com/logto-io/docs/tree/master/i18n/de/docusaurus-plugin-content-docs/current/authorization/validate-access-tokens/README.mdx","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"sidebar_label":"Zugangstokens in API validieren"},"sidebar":"docsSidebar","previous":{"title":"Organisationsebene API-Ressourcen sch\xfctzen","permalink":"/de/authorization/organization-level-api-resources"},"next":{"title":"Autorisierung (Authorization)","permalink":"/de/authorization/"}}');var i=t(25105),s=t(79621),a=t(38552),o=t(22002),c=t(48715),u=t(38636),d=t(61143),l=t(16043),p=t(43980),h=t(9123),g=t(98497),m=t(4463),f=t(14427),x=t(95290),j=t(5663),A=t(36571);const w=[...A.RM,...x.RM,...j.RM,...f.RM];function b(e){return(0,i.jsxs)(o.A,{groupId:"go-framework",children:[(0,i.jsx)(a.A,{value:"gin",label:"Gin",children:(0,i.jsx)(A.Ay,{})}),(0,i.jsx)(a.A,{value:"echo",label:"Echo",children:(0,i.jsx)(x.Ay,{})}),(0,i.jsx)(a.A,{value:"fiber",label:"Fiber",children:(0,i.jsx)(j.Ay,{})}),(0,i.jsx)(a.A,{value:"chi",label:"Chi",children:(0,i.jsx)(f.Ay,{})})]})}function y(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(b,{...e})}):b()}var k=t(41307),v=t(78809),z=t(89979),_=t(83597),R=t(59391),S=t(93321);const I=[...R.RM,..._.RM,...z.RM,...S.RM];function E(e){return(0,i.jsxs)(o.A,{groupId:"api-framework",children:[(0,i.jsx)(a.A,{value:"spring-boot",label:"Spring Boot",children:(0,i.jsx)(R.Ay,{})}),(0,i.jsx)(a.A,{value:"quarkus",label:"Quarkus",children:(0,i.jsx)(_.Ay,{})}),(0,i.jsx)(a.A,{value:"micronaut",label:"Micronaut",children:(0,i.jsx)(z.Ay,{})}),(0,i.jsx)(a.A,{value:"vertx-web",label:"Vert.x Web",children:(0,i.jsx)(S.Ay,{})})]})}function T(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(E,{...e})}):E()}var q=t(4969),C=t(89739);function J(e){const n={code:"code",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(o.A,{groupId:"api-framework",children:[(0,i.jsx)(a.A,{value:"express",label:"Express.js",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:'title="app.ts"',children:"import express from 'express';\nimport { verifyAccessToken } from './auth-middleware.js';\n\nconst app = express();\n\napp.get('/api/protected', verifyAccessToken, (req, res) => {\n  // Greife direkt \xfcber req.auth auf Authentifizierungsinformationen zu\n  res.json({ auth: req.auth });\n});\n\napp.get('/api/protected/detailed', verifyAccessToken, (req, res) => {\n  // Deine gesch\xfctzte Endpunkt-Logik\n  res.json({\n    auth: req.auth,\n    message: 'Gesch\xfctzte Daten erfolgreich abgerufen',\n  });\n});\n\napp.listen(3000);\n"})})}),(0,i.jsx)(a.A,{value:"koa",label:"Koa.js",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:'title="app.ts"',children:"import Koa from 'koa';\nimport Router from '@koa/router';\nimport { koaVerifyAccessToken } from './auth-middleware.js';\n\nconst app = new Koa();\nconst router = new Router();\n\nrouter.get('/api/protected', koaVerifyAccessToken, (ctx) => {\n  // Greife direkt \xfcber ctx.state.auth auf Authentifizierungsinformationen zu\n  ctx.body = { auth: ctx.state.auth };\n});\n\nrouter.get('/api/protected/detailed', koaVerifyAccessToken, (ctx) => {\n  // Deine gesch\xfctzte Endpunkt-Logik\n  ctx.body = {\n    auth: ctx.state.auth,\n    message: 'Gesch\xfctzte Daten erfolgreich abgerufen',\n  };\n});\n\napp.use(router.routes());\napp.listen(3000);\n"})})}),(0,i.jsx)(a.A,{value:"fastify",label:"Fastify",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:'title="app.ts"',children:"import Fastify from 'fastify';\nimport { fastifyVerifyAccessToken } from './auth-middleware.js';\n\nconst fastify = Fastify();\n\nserver.get('/api/protected', { preHandler: fastifyVerifyAccessToken }, (request, reply) => {\n  // Greife direkt \xfcber request.auth auf Authentifizierungsinformationen zu\n  reply.send({ auth: request.auth });\n});\n\nserver.get(\n  '/api/protected/detailed',\n  { preHandler: fastifyVerifyAccessToken },\n  (request, reply) => {\n    // Deine gesch\xfctzte Endpunkt-Logik\n    reply.send({\n      auth: request.auth,\n      message: 'Gesch\xfctzte Daten erfolgreich abgerufen',\n    });\n  }\n);\n\nfastify.listen({ port: 3000 });\n"})})}),(0,i.jsx)(a.A,{value:"hapi",label:"Hapi.js",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:'title="app.ts"',children:"import Hapi from '@hapi/hapi';\nimport { hapiVerifyAccessToken } from './auth-middleware.js';\n\nconst server = Hapi.server({ port: 3000 });\n\nserver.route({\n  method: 'GET',\n  path: '/api/protected',\n  options: {\n    pre: [{ method: hapiVerifyAccessToken }],\n    handler: (request, h) => {\n      // Greife auf Authentifizierungsinformationen \xfcber request.app.auth zu\n      return { auth: request.app.auth };\n    },\n  },\n});\n\nserver.route({\n  method: 'GET',\n  path: '/api/protected/detailed',\n  options: {\n    pre: [{ method: hapiVerifyAccessToken }],\n    handler: (request, h) => {\n      // Deine gesch\xfctzte Endpunkt-Logik\n      return {\n        auth: request.app.auth,\n        message: 'Gesch\xfctzte Daten erfolgreich abgerufen',\n      };\n    },\n  },\n});\n\nawait server.start();\n"})})}),(0,i.jsx)(a.A,{value:"nestjs",label:"NestJS",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:'title="protected.controller.ts"',children:"import { Controller, Get, UseGuards, Req } from '@nestjs/common';\nimport { AccessTokenGuard } from './access-token.guard.js';\n\n@Controller('api')\nexport class ProtectedController {\n  @Get('protected')\n  @UseGuards(AccessTokenGuard)\n  getProtected(@Req() req: any) {\n    // Greife auf Authentifizierungsinformationen \xfcber req.auth zu\n    return { auth: req.auth };\n  }\n\n  @Get('protected/detailed')\n  @UseGuards(AccessTokenGuard)\n  getDetailedProtected(@Req() req: any) {\n    // Deine gesch\xfctzte Endpunkt-Logik\n    return {\n      auth: req.auth,\n      message: 'Gesch\xfctzte Daten erfolgreich abgerufen',\n    };\n  }\n}\n"})})})]})}function P(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(J,{...e})}):J(e)}var O=t(94612),N=t(14167),V=t(33435),M=t(33478),B=t(32964),$=t(15142);const F=[...M.RM,...$.RM,...B.RM];function W(e){return(0,i.jsxs)(o.A,{groupId:"api-framework",children:[(0,i.jsx)(a.A,{value:"laravel",label:(0,V.My)("laravel"),children:(0,i.jsx)(M.Ay,{})}),(0,i.jsx)(a.A,{value:"symfony",label:(0,V.My)("symfony"),children:(0,i.jsx)($.Ay,{})}),(0,i.jsx)(a.A,{value:"slim",label:(0,V.My)("slim"),children:(0,i.jsx)(B.Ay,{})})]})}function H(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(W,{...e})}):W()}var D=t(39365),K=t(86881),U=t(18588),L=t(77437),G=t(8675),Z=t(10074);const Y=[...G.RM,...Z.RM,...U.RM,...L.RM];function Q(e){return(0,i.jsxs)(o.A,{groupId:"api-framework",children:[(0,i.jsx)(a.A,{value:"fastapi",label:(0,V.My)("fastapi"),children:(0,i.jsx)(G.Ay,{})}),(0,i.jsx)(a.A,{value:"flask",label:(0,V.My)("flask"),children:(0,i.jsx)(Z.Ay,{})}),(0,i.jsx)(a.A,{value:"django",label:(0,V.My)("django"),children:(0,i.jsx)(U.Ay,{})}),(0,i.jsx)(a.A,{value:"django-rest",label:(0,V.My)("django-rest"),children:(0,i.jsx)(L.Ay,{})})]})}function X(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(Q,{...e})}):Q()}var ee=t(23335),ne=t(61633),te=t(81420),re=t(77406),ie=t(51641);const se=[...re.RM,...ie.RM,...te.RM];function ae(e){return(0,i.jsxs)(o.A,{groupId:"api-framework",children:[(0,i.jsx)(a.A,{value:"rails",label:(0,V.My)("rails"),children:(0,i.jsx)(re.Ay,{})}),(0,i.jsx)(a.A,{value:"sinatra",label:(0,V.My)("sinatra"),children:(0,i.jsx)(ie.Ay,{})}),(0,i.jsx)(a.A,{value:"grape",label:(0,V.My)("grape"),children:(0,i.jsx)(te.Ay,{})})]})}function oe(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(ae,{...e})}):ae()}var ce=t(93745),ue=t(40930),de=t(65487),le=t(3692),pe=t(39427);const he=[...le.RM,...de.RM,...pe.RM];function ge(e){return(0,i.jsxs)(o.A,{groupId:"api-framework",children:[(0,i.jsx)(a.A,{value:"axum",label:(0,V.My)("axum"),children:(0,i.jsx)(le.Ay,{})}),(0,i.jsx)(a.A,{value:"actix-web",label:(0,V.My)("actix-web"),children:(0,i.jsx)(de.Ay,{})}),(0,i.jsx)(a.A,{value:"rocket",label:(0,V.My)("rocket"),children:(0,i.jsx)(pe.Ay,{})})]})}function me(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(ge,{...e})}):ge()}var fe=t(93867);const xe={sidebar_position:6,sidebar_label:"Zugangstokens in API validieren"},je="Wie du Zugangstokens in deinem API-Dienst oder Backend validierst",Ae={},we=[{value:"Bevor du beginnst",id:"before-you-start",level:2},{value:"Schritt 1: Konstanten und Hilfsfunktionen initialisieren",id:"step-1-initialize-constants-and-utilities",level:2},...l.RM,...O.RM,...ee.RM,...k.RM,...q.RM,...d.RM,...D.RM,...ce.RM,...fe.RM,{value:"Schritt 2: Informationen \xfcber deinen Logto-Tenant abrufen",id:"step-2-retrieve-info-about-your-logto-tenant",level:2},...p.RM,{value:"Schritt 3: Das Token und die Berechtigungen validieren",id:"step-3-validate-the-token-and-permissions",level:2},...g.RM,{value:"Die Validierungslogik hinzuf\xfcgen",id:"add-the-validation-logic",level:3},...C.RM,...K.RM,...m.RM,...v.RM,...c.RM,...N.RM,...ne.RM,...ue.RM,{value:"Schritt 4: Middleware auf deine API anwenden",id:"step-4-apply-middleware-to-your-api",level:2},...Y,...w,...I,...u.RM,...F,...se,...he,{value:"Schritt 5: Deine Implementierung testen",id:"step-5-test-your-implementation",level:2},...h.RM,{value:"Verwandte Ressourcen",id:"related-resources",level:2}];function be(e){const n={a:"a",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components},{Url:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Url",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"wie-du-zugangstokens-in-deinem-api-dienst-oder-backend-validierst",children:"Wie du Zugangstokens in deinem API-Dienst oder Backend validierst"})}),"\n",(0,i.jsxs)(n.p,{children:["Die Validierung von Zugangstokens ist ein entscheidender Bestandteil der Durchsetzung der ",(0,i.jsx)(n.a,{href:"/authorization/role-based-access-control",children:"rollenbasierten Zugangskontrolle (RBAC)"})," in Logto. Diese Anleitung f\xfchrt dich durch die \xdcberpr\xfcfung von von Logto ausgestellten JWTs in deinem Backend / API, einschlie\xdflich der Pr\xfcfung von Signatur, Aussteller (Issuer), Zielgruppe (Audience), Ablauf, Berechtigungen (Scopes) und Organisationskontext."]}),"\n",(0,i.jsx)(n.h2,{id:"before-you-start",children:"Bevor du beginnst"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Diese Anleitung setzt voraus, dass du mit den RBAC-Konzepten von Logto vertraut bist."}),"\n",(0,i.jsxs)(n.li,{children:["Wenn du API-Ressourcen sch\xfctzt, wird vorausgesetzt, dass du die Anleitung ",(0,i.jsx)(n.a,{href:"/authorization/global-api-resources",children:"Globale API-Ressourcen sch\xfctzen"})," durchgearbeitet hast."]}),"\n",(0,i.jsxs)(n.li,{children:["Wenn du In-App-Features oder Workflows (nicht-API-Berechtigungen) sch\xfctzt, wird vorausgesetzt, dass du die Anleitung ",(0,i.jsx)(n.a,{href:"/authorization/organization-permissions",children:"Organisations-(Nicht-API-)Berechtigungen sch\xfctzen"})," durchgearbeitet hast."]}),"\n",(0,i.jsxs)(n.li,{children:["Wenn du organisationsbezogene API-Ressourcen sch\xfctzt, wird vorausgesetzt, dass du die Anleitung ",(0,i.jsx)(n.a,{href:"/authorization/organization-level-api-resources",children:"Organisationsbezogene API-Ressourcen sch\xfctzen"})," durchgearbeitet hast."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"step-1-initialize-constants-and-utilities",children:"Schritt 1: Konstanten und Hilfsfunktionen initialisieren"}),"\n",(0,i.jsx)(l.Ay,{}),"\n",(0,i.jsxs)(o.A,{groupId:"api-language",children:[(0,i.jsx)(a.A,{value:"node",label:"Node.js",children:(0,i.jsx)(O.Ay,{})}),(0,i.jsx)(a.A,{value:"python",label:"Python",children:(0,i.jsx)(ee.Ay,{})}),(0,i.jsx)(a.A,{value:"go",label:"Go",children:(0,i.jsx)(k.Ay,{})}),(0,i.jsx)(a.A,{value:"java",label:"Java",children:(0,i.jsx)(q.Ay,{})}),(0,i.jsx)(a.A,{value:"dotnet",label:".NET",children:(0,i.jsx)(d.Ay,{})}),(0,i.jsx)(a.A,{value:"php",label:"PHP",children:(0,i.jsx)(D.Ay,{})}),(0,i.jsx)(a.A,{value:"ruby",label:"Ruby",children:(0,i.jsx)(ce.Ay,{})}),(0,i.jsx)(a.A,{value:"rust",label:"Rust",children:(0,i.jsx)(fe.Ay,{})})]}),"\n",(0,i.jsx)(n.h2,{id:"step-2-retrieve-info-about-your-logto-tenant",children:"Schritt 2: Informationen \xfcber deinen Logto-Tenant abrufen"}),"\n",(0,i.jsx)(p.Ay,{}),"\n",(0,i.jsx)(n.h2,{id:"step-3-validate-the-token-and-permissions",children:"Schritt 3: Das Token und die Berechtigungen validieren"}),"\n",(0,i.jsx)(g.Ay,{}),"\n",(0,i.jsx)(n.h3,{id:"add-the-validation-logic",children:"Die Validierungslogik hinzuf\xfcgen"}),"\n",(0,i.jsxs)(o.A,{groupId:"api-language",children:[(0,i.jsx)(a.A,{value:"node",label:"Node.js",children:(0,i.jsx)(C.Ay,{})}),(0,i.jsx)(a.A,{value:"python",label:"Python",children:(0,i.jsx)(K.Ay,{})}),(0,i.jsx)(a.A,{value:"go",label:"Go",children:(0,i.jsx)(m.Ay,{})}),(0,i.jsx)(a.A,{value:"java",label:"Java",children:(0,i.jsx)(v.Ay,{})}),(0,i.jsx)(a.A,{value:"dotnet",label:".NET",children:(0,i.jsx)(c.Ay,{})}),(0,i.jsx)(a.A,{value:"php",label:"PHP",children:(0,i.jsx)(N.Ay,{})}),(0,i.jsx)(a.A,{value:"ruby",label:"Ruby",children:(0,i.jsx)(ne.Ay,{})}),(0,i.jsx)(a.A,{value:"rust",label:"Rust",children:(0,i.jsx)(ue.Ay,{})})]}),"\n",(0,i.jsx)(n.h2,{id:"step-4-apply-middleware-to-your-api",children:"Schritt 4: Middleware auf deine API anwenden"}),"\n",(0,i.jsx)(n.p,{children:"Wende die Middleware auf deine gesch\xfctzten API-Routen an."}),"\n",(0,i.jsxs)(o.A,{groupId:"api-language",children:[(0,i.jsx)(a.A,{value:"node",label:"Node.js",children:(0,i.jsx)(P,{})}),(0,i.jsx)(a.A,{value:"python",label:"Python",children:(0,i.jsx)(X,{})}),(0,i.jsx)(a.A,{value:"go",label:"Go",children:(0,i.jsx)(y,{})}),(0,i.jsx)(a.A,{value:"java",label:"Java",children:(0,i.jsx)(T,{})}),(0,i.jsx)(a.A,{value:"dotnet",label:".NET",children:(0,i.jsx)(u.Ay,{})}),(0,i.jsx)(a.A,{value:"php",label:"PHP",children:(0,i.jsx)(H,{})}),(0,i.jsx)(a.A,{value:"ruby",label:"Ruby",children:(0,i.jsx)(oe,{})}),(0,i.jsx)(a.A,{value:"rust",label:"Rust",children:(0,i.jsx)(me,{})})]}),"\n",(0,i.jsx)(n.h2,{id:"step-5-test-your-implementation",children:"Schritt 5: Deine Implementierung testen"}),"\n",(0,i.jsx)(h.Ay,{}),"\n",(0,i.jsx)(n.h2,{id:"related-resources",children:"Verwandte Ressourcen"}),"\n",(0,i.jsx)(t,{href:"/developers/custom-token-claims",children:"Token-Anspr\xfcche anpassen"}),"\n",(0,i.jsx)(t,{href:"https://auth.wiki/jwt",children:"JSON Web Token (JWT)"}),"\n",(0,i.jsx)(t,{href:"https://openid.net/specs/openid-connect-discovery-1_0.html",children:(0,i.jsx)(n.p,{children:"OpenID Connect Discovery"})}),"\n",(0,i.jsx)(t,{href:"https://www.rfc-editor.org/rfc/rfc8707.html",children:"RFC 8707: Ressourcenindikatoren"})]})}function ye(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(be,{...e})}):be(e)}},48715:(e,n,t)=>{t.d(n,{Ay:()=>u,RM:()=>o});var r=t(25105),i=t(79621),s=t(38552),a=t(22002);const o=[];function c(e){const n={code:"code",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"F\xfcge das erforderliche NuGet-Paket f\xfcr JWT-Authentifizierung hinzu:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="8.0.0" />\n'})}),"\n",(0,r.jsx)(n.p,{children:"Erstelle einen Validierungsdienst, um die Tokenvalidierung zu \xfcbernehmen:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",metastring:'title="JwtValidationService.cs"',children:'using System.Security.Claims;\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing YourApiNamespace.Exceptions;\n\nnamespace YourApiNamespace.Services\n{\n    public interface IJwtValidationService\n    {\n        Task ValidateTokenAsync(TokenValidatedContext context);\n    }\n\n    public class JwtValidationService : IJwtValidationService\n    {\n        public async Task ValidateTokenAsync(TokenValidatedContext context)\n        {\n            var principal = context.Principal!;\n\n            try\n            {\n                // F\xfcge hier deine Validierungslogik basierend auf dem Berechtigungsmodell ein\n                ValidatePayload(principal);\n            }\n            catch (AuthorizationException)\n            {\n                throw; // Autorisierungsfehler erneut ausl\xf6sen\n            }\n            catch (Exception ex)\n            {\n                throw new AuthorizationException($"Tokenvalidierung fehlgeschlagen: {ex.Message}", 401);\n            }\n        }\n\n        private void ValidatePayload(ClaimsPrincipal principal)\n        {\n            // Implementiere hier deine \xdcberpr\xfcfungslogik basierend auf dem Berechtigungsmodell\n            // Dies wird im Abschnitt zu den Berechtigungsmodellen unten gezeigt\n        }\n    }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Konfiguriere die JWT-Authentifizierung in deiner ",(0,r.jsx)(n.code,{children:"Program.cs"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",metastring:'title="Program.cs"',children:'using Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.IdentityModel.Tokens;\nusing YourApiNamespace.Services;\nusing YourApiNamespace.Exceptions;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// F\xfcge Dienste zum Container hinzu\nbuilder.Services.AddControllers();\nbuilder.Services.AddScoped<IJwtValidationService, JwtValidationService>();\n\n// Konfiguriere JWT-Authentifizierung\nbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n    .AddJwtBearer(options =>\n    {\n        options.Authority = AuthConstants.Issuer;\n        options.MetadataAddress = $"{AuthConstants.Issuer}/.well-known/openid_configuration";\n        options.RequireHttpsMetadata = true;\n        options.TokenValidationParameters = new TokenValidationParameters\n        {\n            ValidateIssuer = true,\n            ValidIssuer = AuthConstants.Issuer,\n            ValidateAudience = false, // Die Zielgruppe wird manuell basierend auf dem Berechtigungsmodell validiert\n            ValidateLifetime = true,\n            ValidateIssuerSigningKey = true,\n            ClockSkew = TimeSpan.FromMinutes(5)\n        };\n\n        options.Events = new JwtBearerEvents\n        {\n            OnTokenValidated = async context =>\n            {\n                var validationService = context.HttpContext.RequestServices\n                    .GetRequiredService<IJwtValidationService>();\n\n                await validationService.ValidateTokenAsync(context);\n            },\n            OnAuthenticationFailed = context =>\n            {\n                // Behandle JWT-Bibliotheksfehler als 401\n                context.Response.StatusCode = 401;\n                context.Response.ContentType = "application/json";\n                context.Response.WriteAsync($"{{\\"error\\": \\"Invalid token\\"}}");\n                context.HandleResponse();\n                return Task.CompletedTask;\n            }\n        };\n    });\n\nbuilder.Services.AddAuthorization();\n\nvar app = builder.Build();\n\n// Globale Fehlerbehandlung f\xfcr Authentifizierungs- / Autorisierungsfehler\napp.Use(async (context, next) =>\n{\n    try\n    {\n        await next();\n    }\n    catch (AuthorizationException ex)\n    {\n        context.Response.StatusCode = ex.StatusCode;\n        context.Response.ContentType = "application/json";\n        await context.Response.WriteAsync($"{{\\"error\\": \\"{ex.Message}\\"}}");\n    }\n});\n\n// Konfiguriere die HTTP-Request-Pipeline\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Implementiere entsprechend deinem Berechtigungsmodell die passende Validierungslogik in ",(0,r.jsx)(n.code,{children:"JwtValidationService"}),":"]}),"\n",(0,r.jsxs)(a.A,{groupId:"permission-models",children:[(0,r.jsx)(s.A,{value:"global-api-resources",label:"Globale API-Ressourcen",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",metastring:'title="JwtValidationService.cs"',children:'private void ValidatePayload(ClaimsPrincipal principal)\n{\n    // \xdcberpr\xfcfe, ob der Audience-Claim mit deinem API-Ressourcenindikator \xfcbereinstimmt\n    var audiences = principal.FindAll("aud").Select(c => c.Value).ToList();\n    if (!audiences.Contains("https://your-api-resource-indicator"))\n    {\n        throw new AuthorizationException("Ung\xfcltige Zielgruppe (audience)");\n    }\n\n    // \xdcberpr\xfcfe erforderliche Berechtigungen f\xfcr globale API-Ressourcen\n    var requiredScopes = new[] { "api:read", "api:write" }; // Ersetze durch deine tats\xe4chlichen erforderlichen Berechtigungen\n    var tokenScopes = principal.FindFirst("scope")?.Value?.Split(\' \') ?? Array.Empty<string>();\n\n    if (!requiredScopes.All(scope => tokenScopes.Contains(scope)))\n    {\n        throw new AuthorizationException("Unzureichende Berechtigung (scope)");\n    }\n}\n'})})}),(0,r.jsx)(s.A,{value:"organization-permissions",label:"Organisation (nicht-API) Berechtigungen",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",metastring:'title="JwtValidationService.cs"',children:'private void ValidatePayload(ClaimsPrincipal principal)\n{\n    // \xdcberpr\xfcfe, ob der Audience-Claim dem Organisationsformat entspricht\n    var audiences = principal.FindAll("aud").Select(c => c.Value).ToList();\n    var hasOrgAudience = audiences.Any(aud => aud.StartsWith("urn:logto:organization:"));\n\n    if (!hasOrgAudience)\n    {\n        throw new AuthorizationException("Ung\xfcltige Zielgruppe f\xfcr Organisationsberechtigungen");\n    }\n\n    // \xdcberpr\xfcfe, ob die Organisations-ID mit dem Kontext \xfcbereinstimmt (ggf. aus dem Request-Kontext extrahieren)\n    var expectedOrgId = "your-organization-id"; // Aus dem Request-Kontext extrahieren\n    var expectedAud = $"urn:logto:organization:{expectedOrgId}";\n    if (!audiences.Contains(expectedAud))\n    {\n        throw new AuthorizationException("Organisation-ID stimmt nicht \xfcberein");\n    }\n\n    // \xdcberpr\xfcfe erforderliche Organisationsberechtigungen\n    var requiredScopes = new[] { "invite:users", "manage:settings" }; // Ersetze durch deine tats\xe4chlichen erforderlichen Berechtigungen\n    var tokenScopes = principal.FindFirst("scope")?.Value?.Split(\' \') ?? Array.Empty<string>();\n\n    if (!requiredScopes.All(scope => tokenScopes.Contains(scope)))\n    {\n        throw new AuthorizationException("Unzureichende Organisationsberechtigung (scope)");\n    }\n}\n'})})}),(0,r.jsx)(s.A,{value:"organization-level-api-resources",label:"Organisationsbezogene API-Ressourcen",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",metastring:'title="JwtValidationService.cs"',children:'private void ValidatePayload(ClaimsPrincipal principal)\n{\n    // \xdcberpr\xfcfe, ob der Audience-Claim mit deinem API-Ressourcenindikator \xfcbereinstimmt\n    var audiences = principal.FindAll("aud").Select(c => c.Value).ToList();\n    if (!audiences.Contains("https://your-api-resource-indicator"))\n    {\n        throw new AuthorizationException("Ung\xfcltige Zielgruppe f\xfcr organisationsbezogene API-Ressourcen");\n    }\n\n    // \xdcberpr\xfcfe, ob die Organisations-ID mit dem Kontext \xfcbereinstimmt (ggf. aus dem Request-Kontext extrahieren)\n    var expectedOrgId = "your-organization-id"; // Aus dem Request-Kontext extrahieren\n    var orgId = principal.FindFirst("organization_id")?.Value;\n    if (!expectedOrgId.Equals(orgId))\n    {\n        throw new AuthorizationException("Organisation-ID stimmt nicht \xfcberein");\n    }\n\n    // \xdcberpr\xfcfe erforderliche Berechtigungen f\xfcr organisationsbezogene API-Ressourcen\n    var requiredScopes = new[] { "api:read", "api:write" }; // Ersetze durch deine tats\xe4chlichen erforderlichen Berechtigungen\n    var tokenScopes = principal.FindFirst("scope")?.Value?.Split(\' \') ?? Array.Empty<string>();\n\n    if (!requiredScopes.All(scope => tokenScopes.Contains(scope)))\n    {\n        throw new AuthorizationException("Unzureichende organisationsbezogene API-Berechtigungen (scope)");\n    }\n}\n'})})})]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},38636:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Wir haben bereits die Authentifizierungs- und Autorisierungsmiddleware in den vorherigen Abschnitten eingerichtet. Jetzt k\xf6nnen wir einen gesch\xfctzten Controller erstellen, der Zugangstokens validiert und Anspr\xfcche (Claims) aus authentifizierten Anfragen extrahiert."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",metastring:'title="ProtectedController.cs"',children:'using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing System.Security.Claims;\n\nnamespace YourApiNamespace.Controllers\n{\n    [ApiController]\n    [Route("api/[controller]")]\n    [Authorize] // Authentifizierung f\xfcr alle Aktionen in diesem Controller erforderlich\n    public class ProtectedController : ControllerBase\n    {\n        [HttpGet]\n        public IActionResult GetProtectedData()\n        {\n            // Informationen aus dem Zugangstoken direkt aus den User-Anspr\xfcchen (Claims) abrufen\n            var sub = User.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? User.FindFirst("sub")?.Value;\n            var clientId = User.FindFirst("client_id")?.Value;\n            var organizationId = User.FindFirst("organization_id")?.Value;\n            var scopes = User.FindFirst("scope")?.Value?.Split(\' \') ?? Array.Empty<string>();\n            var audience = User.FindAll("aud").Select(c => c.Value).ToArray();\n\n            return Ok(new {\n                sub,\n                client_id = clientId,\n                organization_id = organizationId,\n                scopes,\n                audience\n            });\n        }\n\n        [HttpGet("claims")]\n        public IActionResult GetAllClaims()\n        {\n            // Gibt alle Anspr\xfcche (Claims) zur Fehleranalyse / \xdcberpr\xfcfung zur\xfcck\n            var claims = User.Claims.Select(c => new { c.Type, c.Value }).ToList();\n            return Ok(new { claims });\n        }\n    }\n}\n'})})]})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},61143:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",metastring:'title="AuthConstants.cs"',children:'namespace YourApiNamespace\n{\n    public static class AuthConstants\n    {\n        public const string Issuer = "https://your-tenant.logto.app/oidc";\n    }\n}\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",metastring:'title="AuthenticationExceptions.cs"',children:"namespace YourApiNamespace.Exceptions\n{\n    public class AuthorizationException : Exception\n    {\n        public int StatusCode { get; }\n\n        public AuthorizationException(string message, int statusCode = 403) : base(message)\n        {\n            StatusCode = statusCode;\n        }\n    }\n}\n"})})]})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},16043:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",p:"p",...(0,i.R)(),...e.components};return(0,r.jsxs)(n.p,{children:["Definiere die notwendigen Konstanten und Hilfsfunktionen in deinem Code, um die Extraktion und Validierung von Tokens zu handhaben. Eine g\xfcltige Anfrage muss einen ",(0,r.jsx)(n.code,{children:"Authorization"}),"-Header in der Form ",(0,r.jsx)(n.code,{children:"Bearer <Zugangstoken (Access token)>"})," enthalten."]})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},43980:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[{value:"Abrufen vom OpenID Connect Discovery-Endpunkt",id:"fetch-from-openid-connect-discovery-endpoint",level:3},{value:"Im Code fest hinterlegen (nicht empfohlen)",id:"hardcode-in-your-code-not-recommended",level:3}];function a(e){const n={code:"code",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Du ben\xf6tigst die folgenden Werte, um von Logto ausgestellte Tokens zu validieren:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"JSON Web Key Set (JWKS) URI: Die URL zu den \xf6ffentlichen Schl\xfcsseln von Logto, die zur \xdcberpr\xfcfung von JWT-Signaturen verwendet wird."}),"\n",(0,r.jsx)(n.li,{children:"Aussteller (Issuer): Der erwartete Ausstellerwert (die OIDC-URL von Logto)."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Zuerst finde den Endpunkt deines Logto-Tenants. Du findest ihn an verschiedenen Stellen:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["In der Logto-Konsole unter ",(0,r.jsx)(n.strong,{children:"Einstellungen"})," \u2192 ",(0,r.jsx)(n.strong,{children:"Domains"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["In den Anwendungseinstellungen, die du in Logto konfiguriert hast, unter ",(0,r.jsx)(n.strong,{children:"Einstellungen"})," \u2192 ",(0,r.jsx)(n.strong,{children:"Endpoints & Credentials"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"fetch-from-openid-connect-discovery-endpoint",children:"Abrufen vom OpenID Connect Discovery-Endpunkt"}),"\n",(0,r.jsx)(n.p,{children:"Diese Werte k\xf6nnen vom OpenID Connect Discovery-Endpunkt von Logto abgerufen werden:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"https://<your-logto-endpoint>/oidc/.well-known/openid-configuration\n"})}),"\n",(0,r.jsx)(n.p,{children:"Hier ist ein Beispiel f\xfcr eine Antwort (andere Felder wurden zur \xdcbersichtlichkeit weggelassen):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "jwks_uri": "https://your-tenant.logto.app/oidc/jwks",\n  "issuer": "https://your-tenant.logto.app/oidc"\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"hardcode-in-your-code-not-recommended",children:"Im Code fest hinterlegen (nicht empfohlen)"}),"\n",(0,r.jsx)(n.p,{children:"Da Logto keine Anpassung der JWKS-URI oder des Ausstellers (Issuer) erlaubt, kannst du diese Werte fest in deinem Code hinterlegen. Dies wird jedoch f\xfcr Produktionsanwendungen nicht empfohlen, da dies den Wartungsaufwand erh\xf6hen kann, falls sich zuk\xfcnftig Konfigurationen \xe4ndern."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["JWKS URI: ",(0,r.jsx)(n.code,{children:"https://<your-logto-endpoint>/oidc/jwks"})]}),"\n",(0,r.jsxs)(n.li,{children:["Aussteller (Issuer): ",(0,r.jsx)(n.code,{children:"https://<your-logto-endpoint>/oidc"})]}),"\n"]})]})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},9123:(e,n,t)=>{t.d(n,{Ay:()=>u,RM:()=>o});var r=t(25105),i=t(79621),s=t(38552),a=t(22002);const o=[{value:"Zugangstokens erhalten",id:"get-access-tokens",level:3},{value:"Gesch\xfctzte Endpunkte testen",id:"test-protected-endpoints",level:3},{value:"Berechtigungsmodell-spezifisches Testen",id:"permission-model-specific-testing",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h3,{id:"get-access-tokens",children:"Zugangstokens erhalten"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Von deiner Client-Anwendung:"}),"\nWenn du eine Client-Integration eingerichtet hast, kann deine App Tokens automatisch erhalten. Extrahiere das Zugangstoken und verwende es in API-Anfragen."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Zum Testen mit curl / Postman:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Benutzertokens:"})," Verwende die Entwicklertools deiner Client-App, um das Zugangstoken aus dem localStorage oder dem Netzwerk-Tab zu kopieren."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Maschine-zu-Maschine-Tokens:"})," Verwende den Client-Credentials-Flow. Hier ein nicht-normatives Beispiel mit curl:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'curl -X POST https://your-tenant.logto.app/oidc/token \\\n  -H "Content-Type: application/x-www-form-urlencoded" \\\n  -d "grant_type=client_credentials" \\\n  -d "client_id=your-m2m-client-id" \\\n  -d "client_secret=your-m2m-client-secret" \\\n  -d "resource=https://your-api-resource-indicator" \\\n  -d "scope=api:read api:write"\n'})}),"\n",(0,r.jsxs)(n.p,{children:["M\xf6glicherweise musst du die Parameter ",(0,r.jsx)(n.code,{children:"resource"})," und ",(0,r.jsx)(n.code,{children:"scope"})," entsprechend deiner API-Ressource und Berechtigungen anpassen; ein ",(0,r.jsx)(n.code,{children:"organization_id"}),"-Parameter kann ebenfalls erforderlich sein, wenn deine API organisationsgebunden ist."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["M\xf6chtest du den Inhalt des Tokens inspizieren? Verwende unseren ",(0,r.jsx)(n.a,{href:"https://logto.io/jwt-decoder",children:"JWT Decoder"}),", um deine JWTs zu dekodieren und zu \xfcberpr\xfcfen."]})}),"\n",(0,r.jsx)(n.h3,{id:"test-protected-endpoints",children:"Gesch\xfctzte Endpunkte testen"}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:(0,r.jsx)(n.strong,{children:"G\xfcltige Token-Anfrage"})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'curl -H "Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9..." \\\n  http://localhost:3000/api/protected\n'})}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Erwartete Antwort:"})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "auth": {\n    "sub": "user123",\n    "clientId": "app456",\n    "organizationId": "org789",\n    "scopes": ["api:read", "api:write"],\n    "audience": ["https://your-api-resource-indicator"]\n  }\n}\n'})})]}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:(0,r.jsx)(n.strong,{children:"Fehlendes Token"})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"curl http://localhost:3000/api/protected\n"})}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Erwartete Antwort (401):"})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "error": "Authorization header is missing"\n}\n'})})]}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:(0,r.jsx)(n.strong,{children:"Ung\xfcltiges Token"})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'curl -H "Authorization: Bearer invalid-token" \\\n  http://localhost:3000/api/protected\n'})}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Erwartete Antwort (401):"})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "error": "Invalid token"\n}\n'})})]}),"\n",(0,r.jsx)(n.h3,{id:"permission-model-specific-testing",children:"Berechtigungsmodell-spezifisches Testen"}),"\n",(0,r.jsxs)(a.A,{groupId:"permission-models",children:[(0,r.jsxs)(s.A,{value:"global-api-resources",label:"Globale API-Ressourcen",children:[(0,r.jsx)(n.p,{children:"Testszenarien f\xfcr APIs, die mit globalen Berechtigungen gesch\xfctzt sind:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"G\xfcltige Berechtigungen:"})," Teste mit Tokens, die deine erforderlichen API-Berechtigungen enthalten (z. B. ",(0,r.jsx)(n.code,{children:"api:read"}),", ",(0,r.jsx)(n.code,{children:"api:write"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fehlende Berechtigungen:"})," Erwarte ",(0,r.jsx)(n.strong,{children:"403 Verboten"}),", wenn das Token die erforderlichen Berechtigungen nicht enth\xe4lt"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Falsche Zielgruppe:"})," Erwarte ",(0,r.jsx)(n.strong,{children:"403 Verboten"}),", wenn die Zielgruppe nicht mit der API-Ressource \xfcbereinstimmt"]}),"\n"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'# Token mit fehlenden Berechtigungen - erwarte 403\ncurl -H "Authorization: Bearer token-without-required-scopes" \\\n  http://localhost:3000/api/protected\n'})})]}),(0,r.jsxs)(s.A,{value:"organization-permissions",label:"Organisations-(Nicht-API)-Berechtigungen",children:[(0,r.jsx)(n.p,{children:"Testszenarien f\xfcr organisationsspezifische Zugangskontrolle:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"G\xfcltiges Organisationstoken:"})," Teste mit Tokens, die den korrekten Organisationskontext enthalten (Organisations-ID und Berechtigungen)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fehlende Berechtigungen:"})," Erwarte ",(0,r.jsx)(n.strong,{children:"403 Verboten"}),", wenn der Benutzer keine Berechtigungen f\xfcr die angeforderte Aktion hat"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Falsche Organisation:"})," Erwarte ",(0,r.jsx)(n.strong,{children:"403 Verboten"}),", wenn die Zielgruppe nicht mit dem Organisationskontext \xfcbereinstimmt (",(0,r.jsx)(n.code,{children:"urn:logto:organization:<organization_id>"}),")"]}),"\n"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'# Token f\xfcr falsche Organisation - erwarte 403\ncurl -H "Authorization: Bearer token-for-different-organization" \\\n  http://localhost:3000/api/protected\n'})})]}),(0,r.jsxs)(s.A,{value:"organization-level-api-resources",label:"Organisationsgebundene API-Ressourcen",children:[(0,r.jsx)(n.p,{children:"Testszenarien, die API-Ressourcen-Validierung mit Organisationskontext kombinieren:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"G\xfcltige Organisation + API-Berechtigungen:"})," Teste mit Tokens, die sowohl den Organisationskontext als auch die erforderlichen API-Berechtigungen enthalten"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fehlende API-Berechtigungen:"})," Erwarte ",(0,r.jsx)(n.strong,{children:"403 Verboten"}),", wenn das Organisationstoken die erforderlichen API-Berechtigungen nicht enth\xe4lt"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Falsche Organisation:"})," Erwarte ",(0,r.jsx)(n.strong,{children:"403 Verboten"}),", wenn auf die API mit einem Token aus einer anderen Organisation zugegriffen wird"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Falsche Zielgruppe:"})," Erwarte ",(0,r.jsx)(n.strong,{children:"403 Verboten"}),", wenn die Zielgruppe nicht mit der organisationsgebundenen API-Ressource \xfcbereinstimmt"]}),"\n"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'# Organisationstoken ohne API-Berechtigungen - erwarte 403\ncurl -H "Authorization: Bearer organization-token-without-api-scopes" \\\n  http://localhost:3000/api/protected\n'})})]})]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},98497:(e,n,t)=>{t.d(n,{Ay:()=>u,RM:()=>o});var r=t(25105),i=t(79621),s=t(38552),a=t(22002);const o=[{value:"Was bei jedem Berechtigungsmodell zu pr\xfcfen ist",id:"what-to-check-for-each-permission-model",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Nach dem Extrahieren des Tokens und dem Abrufen der OIDC-Konfiguration \xfcberpr\xfcfe Folgendes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Signatur:"})," JWT muss g\xfcltig und von Logto (\xfcber JWKS) signiert sein."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Aussteller (Issuer):"})," Muss mit dem Aussteller deines Logto-Tenants \xfcbereinstimmen."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Zielgruppe (Audience):"})," Muss mit dem in Logto registrierten Ressourcenindikator der API oder dem Organisationskontext (falls zutreffend) \xfcbereinstimmen."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Ablauf (Expiration):"})," Token darf nicht abgelaufen sein."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Berechtigungen (Scopes):"})," Token muss die erforderlichen Berechtigungen f\xfcr deine API / Aktion enthalten. Berechtigungen sind durch Leerzeichen getrennte Zeichenfolgen im ",(0,r.jsx)(n.code,{children:"scope"}),"-Anspruch."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Organisationskontext:"})," Wenn du API-Ressourcen auf Organisationsebene sch\xfctzt, \xfcberpr\xfcfe den ",(0,r.jsx)(n.code,{children:"organization_id"}),"-Anspruch."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Siehe ",(0,r.jsx)(n.a,{href:"https://auth.wiki/jwt",children:"JSON Web Token"}),", um mehr \xfcber die Struktur und Anspr\xfcche von JWT zu erfahren."]}),"\n",(0,r.jsx)(n.h3,{id:"what-to-check-for-each-permission-model",children:"Was bei jedem Berechtigungsmodell zu pr\xfcfen ist"}),"\n",(0,r.jsxs)(a.A,{groupId:"permission-models",children:[(0,r.jsx)(s.A,{value:"global-api-resources",label:"Globale API-Ressourcen",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Audience-Anspruch (",(0,r.jsx)(n.code,{children:"aud"}),"):"]})," API-Ressourcenindikator"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Organisations-Anspruch (",(0,r.jsx)(n.code,{children:"organization_id"}),"):"]})," ",(0,r.jsx)(n.em,{children:"Nicht vorhanden"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Zu pr\xfcfende Berechtigungen (",(0,r.jsx)(n.code,{children:"scope"}),"):"]})," API-Ressourcen-Berechtigungen"]}),"\n"]})}),(0,r.jsx)(s.A,{value:"organization-permissions",label:"Organisation (nicht-API) Berechtigungen",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Audience-Anspruch (",(0,r.jsx)(n.code,{children:"aud"}),"):"]})," ",(0,r.jsx)(n.code,{children:"urn:logto:organization:<id>"})," (Organisationskontext ist im ",(0,r.jsx)(n.code,{children:"aud"}),"-Anspruch)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Organisations-Anspruch (",(0,r.jsx)(n.code,{children:"organization_id"}),"):"]})," ",(0,r.jsx)(n.em,{children:"Nicht vorhanden"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Zu pr\xfcfende Berechtigungen (",(0,r.jsx)(n.code,{children:"scope"}),"):"]})," Organisationsberechtigungen"]}),"\n"]})}),(0,r.jsx)(s.A,{value:"organization-level-api-resources",label:"API-Ressourcen auf Organisationsebene",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Audience-Anspruch (",(0,r.jsx)(n.code,{children:"aud"}),"):"]})," API-Ressourcenindikator"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Organisations-Anspruch (",(0,r.jsx)(n.code,{children:"organization_id"}),"):"]})," Organisations-ID (muss mit Anfrage \xfcbereinstimmen)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Zu pr\xfcfende Berechtigungen (",(0,r.jsx)(n.code,{children:"scope"}),"):"]})," API-Ressourcen-Berechtigungen"]}),"\n"]})})]}),"\n",(0,r.jsx)("small",{children:(0,r.jsxs)(n.p,{children:["F\xfcr nicht-API-Organisationsberechtigungen wird der Organisationskontext durch den ",(0,r.jsx)(n.code,{children:"aud"}),"-Anspruch\ndargestellt (z. B. ",(0,r.jsx)(n.code,{children:"urn:logto:organization:abc123"}),"). Der ",(0,r.jsx)(n.code,{children:"organization_id"}),"-Anspruch ist nur f\xfcr\nTokens von API-Ressourcen auf Organisationsebene vorhanden."]})}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"Validiere immer sowohl Berechtigungen (Scopes) als auch Kontext (Audience, Organisation) f\xfcr sichere Multi-Tenant-APIs."})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},4463:(e,n,t)=>{t.d(n,{Ay:()=>m,RM:()=>h});var r=t(25105),i=t(79621),s=t(33435),a=t(38552),o=t(22002);function c(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",metastring:'title="auth_middleware.go"',children:'import (\n    "context"\n    "encoding/json"\n    "net/http"\n)\n\ntype contextKey string\n\nconst AuthContextKey contextKey = "auth"\n\nfunc VerifyAccessToken(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        tokenString, err := extractBearerTokenFromHeaders(r)\n        if err != nil {\n            authErr := err.(*AuthorizationError)\n            w.Header().Set("Content-Type", "application/json")\n            w.WriteHeader(authErr.Status)\n            json.NewEncoder(w).Encode(map[string]string{"error": authErr.Message})\n            return\n        }\n\n        token, err := validateJWT(tokenString)\n        if err != nil {\n            authErr := err.(*AuthorizationError)\n            w.Header().Set("Content-Type", "application/json")\n            w.WriteHeader(authErr.Status)\n            json.NewEncoder(w).Encode(map[string]string{"error": authErr.Message})\n            return\n        }\n\n        // Token im Kontext f\xfcr generische Nutzung speichern\n        ctx := context.WithValue(r.Context(), AuthContextKey, token)\n        next.ServeHTTP(w, r.WithContext(ctx))\n    })\n}\n'})})}function u(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",metastring:'title="auth_middleware.go"',children:'import "github.com/labstack/echo/v4"\n\nfunc VerifyAccessToken(next echo.HandlerFunc) echo.HandlerFunc {\n    return func(c echo.Context) error {\n        tokenString, err := extractBearerTokenFromHeaders(c.Request())\n        if err != nil {\n            authErr := err.(*AuthorizationError)\n            return c.JSON(authErr.Status, echo.Map{"error": authErr.Message})\n        }\n\n        token, err := validateJWT(tokenString)\n        if err != nil {\n            authErr := err.(*AuthorizationError)\n            return c.JSON(authErr.Status, echo.Map{"error": authErr.Message})\n        }\n\n        // Token im Kontext f\xfcr generische Nutzung speichern\n        c.Set("auth", token)\n        return next(c)\n    }\n}\n'})})}function d(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",metastring:'title="auth_middleware.go"',children:'import (\n    "net/http"\n    "github.com/gofiber/fiber/v2"\n)\n\nfunc VerifyAccessToken(c *fiber.Ctx) error {\n    // Konvertiere die Fiber-Anfrage in eine http.Request f\xfcr Kompatibilit\xe4t\n    req := &http.Request{\n        Header: make(http.Header),\n    }\n    req.Header.Set("Authorization", c.Get("Authorization"))\n\n    tokenString, err := extractBearerTokenFromHeaders(req)\n    if err != nil {\n        authErr := err.(*AuthorizationError)\n        return c.Status(authErr.Status).JSON(fiber.Map{"error": authErr.Message})\n    }\n\n    token, err := validateJWT(tokenString)\n    if err != nil {\n        authErr := err.(*AuthorizationError)\n        return c.Status(authErr.Status).JSON(fiber.Map{"error": authErr.Message})\n    }\n\n    // Speichere das Token in Locals f\xfcr generische Nutzung\n    c.Locals("auth", token)\n    return c.Next()\n}\n'})})}function l(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",metastring:'title="auth_middleware.go"',children:'import "github.com/gin-gonic/gin"\n\nfunc VerifyAccessToken() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        tokenString, err := extractBearerTokenFromHeaders(c.Request)\n        if err != nil {\n            authErr := err.(*AuthorizationError)\n            c.JSON(authErr.Status, gin.H{"error": authErr.Message})\n            c.Abort()\n            return\n        }\n\n        token, err := validateJWT(tokenString)\n        if err != nil {\n            authErr := err.(*AuthorizationError)\n            c.JSON(authErr.Status, gin.H{"error": authErr.Message})\n            c.Abort()\n            return\n        }\n\n        // Token im Kontext f\xfcr generische Nutzung speichern\n        c.Set("auth", token)\n        c.Next()\n    }\n}\n'})})}const p=Object.freeze({gin:(0,r.jsx)((function(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}),{}),fiber:(0,r.jsx)((function(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}),{}),echo:(0,r.jsx)((function(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}),{}),chi:(0,r.jsx)((function(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}),{})}),h=[];function g(e){const n={a:"a",code:"code",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Wir verwenden ",(0,r.jsx)(n.a,{href:"https://github.com/lestrrat-go/jwx",children:"github.com/lestrrat-go/jwx"}),", um JWTs zu validieren. Installiere es, falls du es noch nicht getan hast:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"go mod init your-project\ngo get github.com/lestrrat-go/jwx/v3\n"})}),"\n",(0,r.jsxs)(n.p,{children:["F\xfcge zun\xe4chst diese gemeinsamen Komponenten zu deiner Datei ",(0,r.jsx)(n.code,{children:"auth_middleware.go"})," hinzu:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",metastring:'title="auth_middleware.go"',children:'import (\n    "context"\n    "strings"\n    "time"\n\n    "github.com/lestrrat-go/jwx/v3/jwk"\n    "github.com/lestrrat-go/jwx/v3/jwt"\n)\n\nvar jwkSet jwk.Set\n\nfunc init() {\n    // JWKS-Cache initialisieren\n    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n    defer cancel()\n\n    var err error\n    jwkSet, err = jwk.Fetch(ctx, JWKS_URI)\n    if err != nil {\n        panic("Fehler beim Abrufen von JWKS: " + err.Error())\n    }\n}\n\n// validateJWT validiert das JWT und gibt das geparste Token zur\xfcck\nfunc validateJWT(tokenString string) (jwt.Token, error) {\n    token, err := jwt.Parse([]byte(tokenString), jwt.WithKeySet(jwkSet))\n    if err != nil {\n        return nil, NewAuthorizationError("Ung\xfcltiges Token: "+err.Error(), http.StatusUnauthorized)\n    }\n\n    // Aussteller \xfcberpr\xfcfen\n    if token.Issuer() != ISSUER {\n        return nil, NewAuthorizationError("Ung\xfcltiger Aussteller", http.StatusUnauthorized)\n    }\n\n    if err := verifyPayload(token); err != nil {\n        return nil, err\n    }\n\n    return token, nil\n}\n\n// Hilfsfunktionen zum Extrahieren von Token-Daten\nfunc getStringClaim(token jwt.Token, key string) string {\n    if val, ok := token.Get(key); ok {\n        if str, ok := val.(string); ok {\n            return str\n        }\n    }\n    return ""\n}\n\nfunc getScopesFromToken(token jwt.Token) []string {\n    if val, ok := token.Get("scope"); ok {\n        if scope, ok := val.(string); ok && scope != "" {\n            return strings.Split(scope, " ")\n        }\n    }\n    return []string{}\n}\n\nfunc getAudienceFromToken(token jwt.Token) []string {\n    return token.Audience()\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Implementiere anschlie\xdfend das Middleware, um das Zugangstoken zu \xfcberpr\xfcfen:"}),"\n",e.framework?p[e.framework]:(0,r.jsx)(o.A,{groupId:"api-framework",children:Object.entries(p).map((([e,n])=>(0,r.jsx)(a.A,{value:e,label:(0,s.My)(e),children:n},e)))}),"\n",(0,r.jsxs)(n.p,{children:["Je nach deinem Berechtigungsmodell musst du m\xf6glicherweise unterschiedliche ",(0,r.jsx)(n.code,{children:"verifyPayload"}),"-Logik anwenden:"]}),"\n",(0,r.jsxs)(o.A,{groupId:"permission-models",children:[(0,r.jsx)(a.A,{value:"global-api-resources",label:"Globale API-Ressourcen",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",metastring:'title="auth_middleware.go"',children:'func verifyPayload(token jwt.Token) error {\n    // \xdcberpr\xfcfe, ob der Audience-Anspruch mit deinem API-Ressourcenindikator \xfcbereinstimmt\n    if !hasAudience(token, "https://your-api-resource-indicator") {\n        return NewAuthorizationError("Ung\xfcltige Zielgruppe")\n    }\n\n    // \xdcberpr\xfcfe erforderliche Berechtigungen f\xfcr globale API-Ressourcen\n    requiredScopes := []string{"api:read", "api:write"} // Ersetze durch deine tats\xe4chlichen erforderlichen Berechtigungen\n    if !hasRequiredScopes(token, requiredScopes) {\n        return NewAuthorizationError("Unzureichende Berechtigung")\n    }\n\n    return nil\n}\n'})})}),(0,r.jsx)(a.A,{value:"organization-permissions",label:"Organisation (nicht-API) Berechtigungen",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",metastring:'title="auth_middleware.go"',children:'func verifyPayload(token jwt.Token) error {\n    // \xdcberpr\xfcfe, ob der Audience-Anspruch dem Organisationsformat entspricht\n    if !hasOrganizationAudience(token) {\n        return NewAuthorizationError("Ung\xfcltige Zielgruppe f\xfcr Organisationsberechtigungen")\n    }\n\n    // \xdcberpr\xfcfe, ob die Organisations-ID mit dem Kontext \xfcbereinstimmt (du musst dies ggf. aus dem Request-Kontext extrahieren)\n    expectedOrgID := "your-organization-id" // Aus dem Request-Kontext extrahieren\n    if !hasMatchingOrganization(token, expectedOrgID) {\n        return NewAuthorizationError("Organisation-ID stimmt nicht \xfcberein")\n    }\n\n    // \xdcberpr\xfcfe erforderliche Organisationsberechtigungen\n    requiredScopes := []string{"invite:users", "manage:settings"} // Ersetze durch deine tats\xe4chlichen erforderlichen Berechtigungen\n    if !hasRequiredScopes(token, requiredScopes) {\n        return NewAuthorizationError("Unzureichende Organisationsberechtigung")\n    }\n\n    return nil\n}\n'})})}),(0,r.jsx)(a.A,{value:"organization-level-api-resources",label:"Organisationsbezogene API-Ressourcen",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",metastring:'title="auth_middleware.go"',children:'func verifyPayload(token jwt.Token) error {\n    // \xdcberpr\xfcfe, ob der Audience-Anspruch mit deinem API-Ressourcenindikator \xfcbereinstimmt\n    if !hasAudience(token, "https://your-api-resource-indicator") {\n        return NewAuthorizationError("Ung\xfcltige Zielgruppe f\xfcr organisationsbezogene API-Ressourcen")\n    }\n\n    // \xdcberpr\xfcfe, ob die Organisations-ID mit dem Kontext \xfcbereinstimmt (du musst dies ggf. aus dem Request-Kontext extrahieren)\n    expectedOrgID := "your-organization-id" // Aus dem Request-Kontext extrahieren\n    if !hasMatchingOrganizationID(token, expectedOrgID) {\n        return NewAuthorizationError("Organisation-ID stimmt nicht \xfcberein")\n    }\n\n    // \xdcberpr\xfcfe erforderliche Berechtigungen f\xfcr organisationsbezogene API-Ressourcen\n    requiredScopes := []string{"api:read", "api:write"} // Ersetze durch deine tats\xe4chlichen erforderlichen Berechtigungen\n    if !hasRequiredScopes(token, requiredScopes) {\n        return NewAuthorizationError("Unzureichende organisationsbezogene API-Berechtigungen")\n    }\n\n    return nil\n}\n'})})})]}),"\n",(0,r.jsx)(n.p,{children:"F\xfcge diese Hilfsfunktionen zur Payload-\xdcberpr\xfcfung hinzu:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",metastring:'title="auth_middleware.go"',children:'// hasAudience pr\xfcft, ob das Token die angegebene Zielgruppe enth\xe4lt\nfunc hasAudience(token jwt.Token, expectedAud string) bool {\n    audiences := token.Audience()\n    for _, aud := range audiences {\n        if aud == expectedAud {\n            return true\n        }\n    }\n    return false\n}\n\n// hasOrganizationAudience pr\xfcft, ob das Token eine Zielgruppe im Organisationsformat enth\xe4lt\nfunc hasOrganizationAudience(token jwt.Token) bool {\n    audiences := token.Audience()\n    for _, aud := range audiences {\n        if strings.HasPrefix(aud, "urn:logto:organization:") {\n            return true\n        }\n    }\n    return false\n}\n\n// hasRequiredScopes pr\xfcft, ob das Token alle erforderlichen Berechtigungen enth\xe4lt\nfunc hasRequiredScopes(token jwt.Token, requiredScopes []string) bool {\n    scopes := getScopesFromToken(token)\n    for _, required := range requiredScopes {\n        found := false\n        for _, scope := range scopes {\n            if scope == required {\n                found = true\n                break\n            }\n        }\n        if !found {\n            return false\n        }\n    }\n    return true\n}\n\n// hasMatchingOrganization pr\xfcft, ob die Token-Zielgruppe mit der erwarteten Organisation \xfcbereinstimmt\nfunc hasMatchingOrganization(token jwt.Token, expectedOrgID string) bool {\n    expectedAud := fmt.Sprintf("urn:logto:organization:%s", expectedOrgID)\n    return hasAudience(token, expectedAud)\n}\n\n// hasMatchingOrganizationID pr\xfcft, ob die organization_id des Tokens mit der erwarteten \xfcbereinstimmt\nfunc hasMatchingOrganizationID(token jwt.Token, expectedOrgID string) bool {\n    orgID := getStringClaim(token, "organization_id")\n    return orgID == expectedOrgID\n}\n'})})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(g,{...e})}):g(e)}},41307:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",metastring:'title="auth_middleware.go"',children:'package main\n\nimport (\n    "fmt"\n    "net/http"\n    "strings"\n)\n\nconst (\n    JWKS_URI = "https://your-tenant.logto.app/oidc/jwks"\n    ISSUER   = "https://your-tenant.logto.app/oidc"\n)\n\ntype AuthorizationError struct {\n    Message string\n    Status  int\n}\n\nfunc (e *AuthorizationError) Error() string {\n    return e.Message\n}\n\nfunc NewAuthorizationError(message string, status ...int) *AuthorizationError {\n    statusCode := http.StatusForbidden // Standardm\xe4\xdfig 403 Verboten\n    if len(status) > 0 {\n        statusCode = status[0]\n    }\n    return &AuthorizationError{\n        Message: message,\n        Status:  statusCode,\n    }\n}\n\nfunc extractBearerTokenFromHeaders(r *http.Request) (string, error) {\n    const bearerPrefix = "Bearer "\n\n    authorization := r.Header.Get("Authorization")\n    if authorization == "" {\n        return "", NewAuthorizationError("Authorization-Header fehlt", http.StatusUnauthorized)\n    }\n\n    if !strings.HasPrefix(authorization, bearerPrefix) {\n        return "", NewAuthorizationError(fmt.Sprintf("Authorization-Header muss mit \\"%s\\" beginnen", bearerPrefix), http.StatusUnauthorized)\n    }\n\n    return strings.TrimPrefix(authorization, bearerPrefix), nil\n}\n'})})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},14427:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",metastring:'title="main.go"',children:'package main\n\nimport (\n    "encoding/json"\n    "net/http"\n\n    "github.com/go-chi/chi/v5"\n    "github.com/lestrrat-go/jwx/v3/jwt"\n)\n\nfunc main() {\n    r := chi.NewRouter()\n\n    // Middleware auf gesch\xfctzte Routen anwenden\n    r.With(VerifyAccessToken).Get("/api/protected", func(w http.ResponseWriter, r *http.Request) {\n        // Zugangstoken-Informationen direkt aus dem Kontext\n        tokenInterface := r.Context().Value(AuthContextKey)\n        if tokenInterface == nil {\n            w.Header().Set("Content-Type", "application/json")\n            w.WriteHeader(http.StatusInternalServerError)\n            json.NewEncoder(w).Encode(map[string]string{"error": "Token nicht gefunden"})\n            return\n        }\n\n        token := tokenInterface.(jwt.Token)\n\n        w.Header().Set("Content-Type", "application/json")\n        json.NewEncoder(w).Encode(map[string]interface{}{\n            "sub":             token.Subject(),\n            "client_id":       getStringClaim(token, "client_id"),\n            "organization_id": getStringClaim(token, "organization_id"),\n            "scopes":          getScopesFromToken(token),\n            "audience":        getAudienceFromToken(token),\n        })\n    })\n\n    http.ListenAndServe(":8080", r)\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Oder mit Routengruppen:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",metastring:'title="main.go"',children:'package main\n\nimport (\n    "encoding/json"\n    "net/http"\n\n    "github.com/go-chi/chi/v5"\n    "github.com/lestrrat-go/jwx/v3/jwt"\n)\n\nfunc main() {\n    r := chi.NewRouter()\n\n    // Gesch\xfctzte Routengruppe erstellen\n    r.Route("/api", func(r chi.Router) {\n        r.Use(VerifyAccessToken)\n        r.Get("/protected", func(w http.ResponseWriter, r *http.Request) {\n            // Zugangstoken-Informationen direkt aus dem Kontext\n            token := r.Context().Value(AuthContextKey).(jwt.Token)\n\n            w.Header().Set("Content-Type", "application/json")\n            json.NewEncoder(w).Encode(map[string]interface{}{\n                "sub":             token.Subject(),\n                "client_id":       getStringClaim(token, "client_id"),\n                "organization_id": getStringClaim(token, "organization_id"),\n                "scopes":          getScopesFromToken(token),\n                "audience":        getAudienceFromToken(token),\n                "message":         "Gesch\xfctzte Daten erfolgreich abgerufen",\n            })\n        })\n    })\n\n    http.ListenAndServe(":8080", r)\n}\n'})})]})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},95290:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",metastring:'title="main.go"',children:'package main\n\nimport (\n    "net/http"\n\n    "github.com/labstack/echo/v4"\n    "github.com/lestrrat-go/jwx/v3/jwt"\n)\n\nfunc main() {\n    e := echo.New()\n\n    // Middleware auf gesch\xfctzte Routen anwenden\n    e.GET("/api/protected", func(c echo.Context) error {\n        // Zugangstoken-Informationen direkt aus dem Kontext abrufen\n        tokenInterface := c.Get("auth")\n        if tokenInterface == nil {\n            return c.JSON(http.StatusInternalServerError, echo.Map{"error": "Token nicht gefunden"})\n        }\n\n        token := tokenInterface.(jwt.Token)\n\n        return c.JSON(http.StatusOK, echo.Map{\n            "sub":             token.Subject(),\n            "client_id":       getStringClaim(token, "client_id"),\n            "organization_id": getStringClaim(token, "organization_id"),\n            "scopes":          getScopesFromToken(token),\n            "audience":        getAudienceFromToken(token),\n        })\n    }, VerifyAccessToken)\n\n    e.Start(":8080")\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Oder mit Routengruppen:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",metastring:'title="main.go"',children:'package main\n\nimport (\n    "github.com/labstack/echo/v4"\n    "github.com/lestrrat-go/jwx/v3/jwt"\n)\n\nfunc main() {\n    e := echo.New()\n\n    // Gesch\xfctzte Routengruppe erstellen\n    api := e.Group("/api", VerifyAccessToken)\n    api.GET("/protected", func(c echo.Context) error {\n        // Zugangstoken-Informationen direkt aus dem Kontext abrufen\n        token := c.Get("auth").(jwt.Token)\n\n        return c.JSON(200, echo.Map{\n            "sub":             token.Subject(),\n            "client_id":       getStringClaim(token, "client_id"),\n            "organization_id": getStringClaim(token, "organization_id"),\n            "scopes":          getScopesFromToken(token),\n            "audience":        getAudienceFromToken(token),\n            "message":         "Gesch\xfctzte Daten erfolgreich abgerufen",\n        })\n    })\n\n    e.Start(":8080")\n}\n'})})]})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},5663:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",metastring:'title="main.go"',children:'package main\n\nimport (\n    "github.com/gofiber/fiber/v2"\n    "github.com/lestrrat-go/jwx/v3/jwt"\n)\n\nfunc main() {\n    app := fiber.New()\n\n    // Middleware auf gesch\xfctzte Routen anwenden\n    app.Get("/api/protected", VerifyAccessToken, func(c *fiber.Ctx) error {\n        // Zugangstoken-Informationen direkt aus locals abrufen\n        tokenInterface := c.Locals("auth")\n        if tokenInterface == nil {\n            return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": "Token nicht gefunden"})\n        }\n\n        token := tokenInterface.(jwt.Token)\n\n        return c.JSON(fiber.Map{\n            "sub":             token.Subject(),\n            "client_id":       getStringClaim(token, "client_id"),\n            "organization_id": getStringClaim(token, "organization_id"),\n            "scopes":          getScopesFromToken(token),\n            "audience":        getAudienceFromToken(token),\n        })\n    })\n\n    app.Listen(":8080")\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Oder mit Routengruppen:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",metastring:'title="main.go"',children:'package main\n\nimport (\n    "github.com/gofiber/fiber/v2"\n    "github.com/lestrrat-go/jwx/v3/jwt"\n)\n\nfunc main() {\n    app := fiber.New()\n\n    // Gesch\xfctzte Routengruppe erstellen\n    api := app.Group("/api", VerifyAccessToken)\n    api.Get("/protected", func(c *fiber.Ctx) error {\n        // Zugangstoken-Informationen direkt aus locals abrufen\n        token := c.Locals("auth").(jwt.Token)\n\n        return c.JSON(fiber.Map{\n            "sub":             token.Subject(),\n            "client_id":       getStringClaim(token, "client_id"),\n            "organization_id": getStringClaim(token, "organization_id"),\n            "scopes":          getScopesFromToken(token),\n            "audience":        getAudienceFromToken(token),\n            "message":         "Gesch\xfctzte Daten erfolgreich abgerufen",\n        })\n    })\n\n    app.Listen(":8080")\n}\n'})})]})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},36571:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",metastring:'title="main.go"',children:'package main\n\nimport (\n    "net/http"\n\n    "github.com/gin-gonic/gin"\n    "github.com/lestrrat-go/jwx/v3/jwt"\n)\n\nfunc main() {\n    r := gin.Default()\n\n    // Middleware auf gesch\xfctzte Routen anwenden\n    r.GET("/api/protected", VerifyAccessToken(), func(c *gin.Context) {\n        // Zugangstoken (Access token) Informationen direkt aus dem Kontext abrufen\n        tokenInterface, exists := c.Get("auth")\n        if !exists {\n            c.JSON(http.StatusInternalServerError, gin.H{"error": "Token nicht gefunden"})\n            return\n        }\n\n        token := tokenInterface.(jwt.Token)\n\n        c.JSON(http.StatusOK, gin.H{\n            "sub":             token.Subject(),\n            "client_id":       getStringClaim(token, "client_id"),\n            "organization_id": getStringClaim(token, "organization_id"),\n            "scopes":          getScopesFromToken(token),\n            "audience":        getAudienceFromToken(token),\n        })\n    })\n\n    r.Run(":8080")\n}\n'})})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},78809:(e,n,t)=>{t.d(n,{Ay:()=>m,RM:()=>h});var r=t(25105),i=t(79621),s=t(33435),a=t(38552),o=t(22002);function c(e){const n={code:"code",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["F\xfcge dies zu deiner ",(0,r.jsx)(n.code,{children:"pom.xml"})," hinzu:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"<dependency>\n    <groupId>io.micronaut.security</groupId>\n    <artifactId>micronaut-security-jwt</artifactId>\n</dependency>\n<dependency>\n    <groupId>io.micronaut</groupId>\n    <artifactId>micronaut-http-server-netty</artifactId>\n</dependency>\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:'title="application.yml"',children:"micronaut:\n  security:\n    authentication: bearer\n    token:\n      jwt:\n        signatures:\n          jwks:\n            logto:\n              url: ${JWKS_URI:https://your-tenant.logto.app/oidc/jwks}\n        claims-validators:\n          issuer: ${JWT_ISSUER:https://your-tenant.logto.app/oidc}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",metastring:'title="JwtClaimsValidator.java"',children:'import io.micronaut.security.token.Claims;\nimport io.micronaut.security.token.validator.TokenValidator;\nimport jakarta.inject.Singleton;\nimport org.reactivestreams.Publisher;\nimport reactor.core.publisher.Mono;\nimport java.util.Arrays;\nimport java.util.List;\n\n@Singleton\npublic class JwtClaimsValidator implements TokenValidator {\n\n    @Override\n    public Publisher<Boolean> validateToken(String token, Claims claims) {\n        try {\n            verifyPayload(claims);\n            return Mono.just(true);\n        } catch (AuthorizationException e) {\n            // Micronaut wird den Statuscode entsprechend behandeln\n            return Mono.just(false);\n        }\n    }\n\n    private void verifyPayload(Claims claims) {\n        // Die Aussteller (Issuer)-Validierung wird automatisch durch die Micronaut JWT-Konfiguration \xfcbernommen\n        // Implementiere hier deine zus\xe4tzliche Verifizierungslogik basierend auf dem Berechtigungsmodell\n        // Verwende die untenstehenden Hilfsmethoden zur Anspruchsextraktion\n\n        // Beispiel: throw new AuthorizationException("Unzureichende Berechtigungen");\n    }\n\n    // Hilfsmethoden f\xfcr Micronaut JWT\n    @SuppressWarnings("unchecked")\n    private List<String> extractAudiences(Claims claims) {\n        Object aud = claims.get("aud");\n        if (aud instanceof List) {\n            return (List<String>) aud;\n        } else if (aud instanceof String) {\n            return Arrays.asList((String) aud);\n        }\n        return List.of();\n    }\n\n    private String extractScopes(Claims claims) {\n        return (String) claims.get("scope");\n    }\n\n    private String extractOrganizationId(Claims claims) {\n        return (String) claims.get("organization_id");\n    }\n}\n'})})]})}function u(e){const n={code:"code",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["F\xfcge Folgendes zu deiner ",(0,r.jsx)(n.code,{children:"pom.xml"})," hinzu:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-smallrye-jwt</artifactId>\n</dependency>\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-resteasy-reactive</artifactId>\n</dependency>\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-properties",metastring:'title="application.properties"',children:"# JWT-Konfiguration\nmp.jwt.verify.publickey.location=${JWKS_URI:https://your-tenant.logto.app/oidc/jwks}\nmp.jwt.verify.issuer=${JWT_ISSUER:https://your-tenant.logto.app/oidc}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",metastring:'title="JwtVerificationFilter.java"',children:'import org.eclipse.microprofile.jwt.JsonWebToken;\nimport jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.inject.Inject;\nimport jakarta.ws.rs.container.ContainerRequestContext;\nimport jakarta.ws.rs.container.ContainerRequestFilter;\nimport jakarta.ws.rs.core.Response;\nimport jakarta.ws.rs.ext.Provider;\nimport java.util ArrayList;\nimport java.util.List;\n\n@Provider\n@ApplicationScoped\npublic class JwtVerificationFilter implements ContainerRequestFilter {\n\n    @Inject\n    JsonWebToken jwt;\n\n    @Override\n    public void filter(ContainerRequestContext requestContext) {\n        if (requestContext.getUriInfo().getPath().startsWith("/api/protected")) {\n            try {\n                verifyPayload(jwt);\n                requestContext.setProperty("auth", jwt);\n            } catch (AuthorizationException e) {\n                requestContext.abortWith(\n                    Response.status(e.getStatusCode())\n                        .entity("{\\"error\\": \\"" + e.getMessage() + "\\"}")\n                        .build()\n                );\n            } catch (Exception e) {\n                requestContext.abortWith(\n                    Response.status(401)\n                        .entity("{\\"error\\": \\"Ung\xfcltiges Token\\"}")\n                        .build()\n                );\n            }\n        }\n    }\n\n    private void verifyPayload(JsonWebToken jwt) {\n        // Die Aussteller (Issuer)-Validierung wird automatisch von der Quarkus JWT-Erweiterung \xfcbernommen\n        // Implementiere hier deine zus\xe4tzliche Verifizierungslogik basierend auf dem Berechtigungsmodell\n        // Verwende die untenstehenden Hilfsmethoden zur Anspruchsextraktion\n    }\n\n    // Hilfsmethoden f\xfcr Quarkus JWT\n    private List<String> extractAudiences(JsonWebToken jwt) {\n        return new ArrayList<>(jwt.getAudience());\n    }\n\n    private String extractScopes(JsonWebToken jwt) {\n        return jwt.getClaim("scope");\n    }\n\n    private String extractOrganizationId(JsonWebToken jwt) {\n        return jwt.getClaim("organization_id");\n    }\n}\n'})})]})}function d(e){const n={code:"code",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["F\xfcge dies zu deiner ",(0,r.jsx)(n.code,{children:"pom.xml"})," hinzu:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.security</groupId>\n    <artifactId>spring-security-oauth2-resource-server</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.security</groupId>\n    <artifactId>spring-security-oauth2-jose</artifactId>\n</dependency>\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",metastring:'title="JwtSecurityConfig.java"',children:'import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.oauth2.jwt.JwtDecoder;\nimport org.springframework.security.oauth2.jwt.NimbusJwtDecoder;\nimport org.springframework.security.web.SecurityFilterChain;\n\n@Configuration\n@EnableWebSecurity\npublic class JwtSecurityConfig {\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .authorizeHttpRequests(authz -> authz\n                .requestMatchers("/api/protected/**").authenticated()\n                .anyRequest().permitAll()\n            )\n            .oauth2ResourceServer(oauth2 -> oauth2\n                .jwt(jwt -> jwt.decoder(jwtDecoder()))\n            );\n        return http.build();\n    }\n\n    @Bean\n    public JwtDecoder jwtDecoder() {\n        // Denke daran, diese Umgebungsvariablen in deiner Bereitstellung zu setzen\n        String jwksUri = System.getenv("JWKS_URI");\n        String issuer = System.getenv("JWT_ISSUER");\n\n        return NimbusJwtDecoder.withJwkSetUri(jwksUri)\n            .issuer(issuer)\n            .build();\n    }\n}\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",metastring:'title="JwtValidator.java"',children:'import org.springframework.security.oauth2.jwt.Jwt;\nimport org.springframework.stereotype.Component;\nimport java.util.List;\n\n@Component\npublic class JwtValidator {\n\n    public void verifyPayload(Jwt jwt) {\n        // Die Aussteller-Validierung (Issuer validation) wird automatisch vom Spring Security JWT Decoder \xfcbernommen\n        // Implementiere hier deine zus\xe4tzliche Verifizierungslogik basierend auf dem Berechtigungsmodell\n        // Verwende die untenstehenden Hilfsmethoden zur Anspruchsextraktion (Claim extraction)\n\n        // Beispiel: throw new AuthorizationException("Unzureichende Berechtigungen");\n        // Der Statuscode wird durch das Exception-Handling von Spring Security behandelt\n    }\n\n    // Hilfsmethoden f\xfcr Spring Boot JWT\n    private List<String> extractAudiences(Jwt jwt) {\n        return jwt.getAudience();\n    }\n\n    private String extractScopes(Jwt jwt) {\n        return jwt.getClaimAsString("scope");\n    }\n\n    private String extractOrganizationId(Jwt jwt) {\n        return jwt.getClaimAsString("organization_id");\n    }\n}\n'})})]})}function l(e){const n={code:"code",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["F\xfcge dies zu deiner ",(0,r.jsx)(n.code,{children:"pom.xml"})," hinzu:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"<dependency>\n    <groupId>io.vertx</groupId>\n    <artifactId>vertx-web</artifactId>\n</dependency>\n<dependency>\n    <groupId>io.vertx</groupId>\n    <artifactId>vertx-auth-jwt</artifactId>\n</dependency>\n<dependency>\n    <groupId>io.vertx</groupId>\n    <artifactId>vertx-web-client</artifactId>\n</dependency>\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",metastring:'title="JwtAuthHandler.java"',children:'import io.vertx.core.Future;\nimport io.vertx.core.Handler;\nimport io.vertx.core.Vertx;\nimport io.vertx.core.json.JsonArray;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.ext.auth.jwt.JWTAuth;\nimport io.vertx.ext.auth.jwt.JWTAuthOptions;\nimport io.vertx.ext.web.RoutingContext;\nimport io.vertx.ext.web.client.WebClient;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class JwtAuthHandler implements Handler<RoutingContext> {\n\n    private final JWTAuth jwtAuth;\n    private final WebClient webClient;\n    private final String expectedIssuer;\n    private final String jwksUri;\n\n    public JwtAuthHandler(Vertx vertx) {\n        this.webClient = WebClient.create(vertx);\n        this.jwtAuth = JWTAuth.create(vertx, new JWTAuthOptions());\n\n        // Denke daran, diese Umgebungsvariablen in deiner Bereitstellung zu setzen\n        this.expectedIssuer = System.getenv("JWT_ISSUER");\n        this.jwksUri = System.getenv("JWKS_URI");\n\n        // JWKS abrufen und JWT-Authentifizierung konfigurieren\n        fetchJWKS().onSuccess(jwks -> {\n            // JWKS konfigurieren (vereinfacht \u2013 du ben\xf6tigst m\xf6glicherweise einen richtigen JWKS-Parser)\n        });\n    }\n\n    @Override\n    public void handle(RoutingContext context) {\n        String authHeader = context.request().getHeader("Authorization");\n        if (authHeader == null || !authHeader.startsWith("Bearer ")) {\n            context.response()\n                .setStatusCode(401)\n                .putHeader("Content-Type", "application/json")\n                .end("{\\"error\\": \\"Authorization header missing or invalid\\"}");\n            return;\n        }\n\n        String token = authHeader.substring(7);\n        jwtAuth.authenticate(new JsonObject().put("jwt", token))\n            .onSuccess(user -> {\n                try {\n                    JsonObject principal = user.principal();\n                    verifyPayload(principal);\n                    context.put("auth", principal);\n                    context.next();\n                } catch (AuthorizationException e) {\n                    context.response()\n                        .setStatusCode(e.getStatusCode())  // Verwende den Statuscode der Exception\n                        .putHeader("Content-Type", "application/json")\n                        .end("{\\"error\\": \\"" + e.getMessage() + "\\"}");\n                } catch (Exception e) {\n                    context.response()\n                        .setStatusCode(401)\n                        .putHeader("Content-Type", "application/json")\n                        .end("{\\"error\\": \\"Invalid token\\"}");\n                }\n            })\n            .onFailure(err -> {\n                context.response()\n                    .setStatusCode(401)\n                    .putHeader("Content-Type", "application/json")\n                    .end("{\\"error\\": \\"Invalid token: " + err.getMessage() + "\\"}");\n            });\n    }\n\n    private Future<JsonObject> fetchJWKS() {\n        return webClient.getAbs(this.jwksUri)\n            .send()\n            .map(response -> response.bodyAsJsonObject());\n    }\n\n    private void verifyPayload(JsonObject principal) {\n        // Aussteller (Issuer) manuell f\xfcr Vert.x \xfcberpr\xfcfen\n        String issuer = principal.getString("iss");\n        if (issuer == null || !expectedIssuer.equals(issuer)) {\n            throw new AuthorizationException("Invalid issuer: " + issuer);\n        }\n\n        // Implementiere hier deine zus\xe4tzliche \xdcberpr\xfcfungslogik basierend auf dem Berechtigungsmodell\n        // Verwende die untenstehenden Hilfsmethoden f\xfcr das Extrahieren von Anspr\xfcchen (Claims)\n    }\n\n    // Hilfsmethoden f\xfcr Vert.x JWT\n    private List<String> extractAudiences(JsonObject principal) {\n        JsonArray audiences = principal.getJsonArray("aud");\n        if (audiences != null) {\n            List<String> result = new ArrayList<>();\n            for (Object aud : audiences) {\n                result.add(aud.toString());\n            }\n            return result;\n        }\n        return List.of();\n    }\n\n    private String extractScopes(JsonObject principal) {\n        return principal.getString("scope");\n    }\n\n    private String extractOrganizationId(JsonObject principal) {\n        return principal.getString("organization_id");\n    }\n}\n'})})]})}const p=Object.freeze({"spring-boot":(0,r.jsx)((function(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}),{}),quarkus:(0,r.jsx)((function(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}),{}),micronaut:(0,r.jsx)((function(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}),{}),"vertx-web":(0,r.jsx)((function(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}),{})}),h=[];function g(e){const n={code:"code",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Wir verwenden je nach Framework unterschiedliche JWT-Bibliotheken. Installiere die erforderlichen Abh\xe4ngigkeiten:"}),"\n",e.framework?p[e.framework]:(0,r.jsx)(o.A,{groupId:"api-framework",children:Object.entries(p).map((([e,n])=>(0,r.jsx)(a.A,{value:e,label:(0,s.My)(e),children:n},e)))}),"\n",(0,r.jsx)(n.p,{children:"Implementiere entsprechend deinem Berechtigungsmodell die passende Pr\xfcf-Logik:"}),"\n",(0,r.jsxs)(o.A,{groupId:"permission-models",children:[(0,r.jsx)(a.A,{value:"global-api-resources",label:"Globale API-Ressourcen",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// \xdcberpr\xfcfe, ob der Audience-Anspruch mit deinem API-Ressourcenindikator \xfcbereinstimmt\nList<String> audiences = extractAudiences(token); // Framework-spezifische Extraktion\nif (!audiences.contains("https://your-api-resource-indicator")) {\n    throw new AuthorizationException("Ung\xfcltige Zielgruppe");\n}\n\n// \xdcberpr\xfcfe die erforderlichen Berechtigungen f\xfcr globale API-Ressourcen\nList<String> requiredScopes = Arrays.asList("api:read", "api:write"); // Ersetze durch deine tats\xe4chlichen erforderlichen Berechtigungen\nString scopes = extractScopes(token); // Framework-spezifische Extraktion\nList<String> tokenScopes = scopes != null ? Arrays.asList(scopes.split(" ")) : List.of();\n\nif (!tokenScopes.containsAll(requiredScopes)) {\n    throw new AuthorizationException("Unzureichende Berechtigung");\n}\n'})})}),(0,r.jsx)(a.A,{value:"organization-permissions",label:"Organisations-(Nicht-API)-Berechtigungen",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// \xdcberpr\xfcfe, ob der Audience-Anspruch dem Organisationsformat entspricht\nList<String> audiences = extractAudiences(token); // Framework-spezifische Extraktion\nboolean hasOrgAudience = audiences.stream()\n    .anyMatch(aud -> aud.startsWith("urn:logto:organization:"));\n\nif (!hasOrgAudience) {\n    throw new AuthorizationException("Ung\xfcltige Zielgruppe f\xfcr Organisationsberechtigungen");\n}\n\n// \xdcberpr\xfcfe, ob die Organisations-ID mit dem Kontext \xfcbereinstimmt (du musst sie ggf. aus dem Request-Kontext extrahieren)\nString expectedOrgId = "your-organization-id"; // Aus dem Request-Kontext extrahieren\nString expectedAud = "urn:logto:organization:" + expectedOrgId;\nif (!audiences.contains(expectedAud)) {\n    throw new AuthorizationException("Organisations-ID stimmt nicht \xfcberein");\n}\n\n// \xdcberpr\xfcfe die erforderlichen Organisationsberechtigungen\nList<String> requiredScopes = Arrays.asList("invite:users", "manage:settings"); // Ersetze durch deine tats\xe4chlichen erforderlichen Berechtigungen\nString scopes = extractScopes(token); // Framework-spezifische Extraktion\nList<String> tokenScopes = scopes != null ? Arrays.asList(scopes.split(" ")) : List.of();\n\nif (!tokenScopes.containsAll(requiredScopes)) {\n    throw new AuthorizationException("Unzureichende Organisationsberechtigung");\n}\n'})})}),(0,r.jsx)(a.A,{value:"organization-level-api-resources",label:"Organisationsbezogene API-Ressourcen",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// \xdcberpr\xfcfe, ob der Audience-Anspruch mit deinem API-Ressourcenindikator \xfcbereinstimmt\nList<String> audiences = extractAudiences(token); // Framework-spezifische Extraktion\nif (!audiences.contains("https://your-api-resource-indicator")) {\n    throw new AuthorizationException("Ung\xfcltige Zielgruppe f\xfcr organisationsbezogene API-Ressourcen");\n}\n\n// \xdcberpr\xfcfe, ob die Organisations-ID mit dem Kontext \xfcbereinstimmt (du musst sie ggf. aus dem Request-Kontext extrahieren)\nString expectedOrgId = "your-organization-id"; // Aus dem Request-Kontext extrahieren\nString orgId = extractOrganizationId(token); // Framework-spezifische Extraktion\nif (!expectedOrgId.equals(orgId)) {\n    throw new AuthorizationException("Organisations-ID stimmt nicht \xfcberein");\n}\n\n// \xdcberpr\xfcfe die erforderlichen Berechtigungen f\xfcr organisationsbezogene API-Ressourcen\nList<String> requiredScopes = Arrays.asList("api:read", "api:write"); // Ersetze durch deine tats\xe4chlichen erforderlichen Berechtigungen\nString scopes = extractScopes(token); // Framework-spezifische Extraktion\nList<String> tokenScopes = scopes != null ? Arrays.asList(scopes.split(" ")) : List.of();\n\nif (!tokenScopes.containsAll(requiredScopes)) {\n    throw new AuthorizationException("Unzureichende organisationsbezogene API-Berechtigungen");\n}\n'})})})]}),"\n",(0,r.jsx)(n.p,{children:"Die Hilfsmethoden zum Extrahieren von Anspr\xfcchen sind framework-spezifisch. Siehe die Implementierungsdetails in den oben genannten framework-spezifischen Validierungsdateien."})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(g,{...e})}):g(e)}},4969:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",metastring:'title="AuthorizationException.java"',children:"public class AuthorizationException extends RuntimeException {\n    private final int statusCode;\n\n    public AuthorizationException(String message) {\n        this(message, 403); // Standardm\xe4\xdfig 403 Verboten (Forbidden)\n    }\n\n    public AuthorizationException(String message, int statusCode) {\n        super(message);\n        this.statusCode = statusCode;\n    }\n\n    public int getStatusCode() {\n        return statusCode;\n    }\n}\n"})})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},89979:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",metastring:'title="ProtectedController.java"',children:'import io.micronaut.http.annotation.Controller;\nimport io.micronaut.http.annotation.Get;\nimport io.micronaut.security.annotation.Secured;\nimport io.micronaut.security.authentication.Authentication;\nimport io.micronaut.security.rules.SecurityRule;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\n\n@Controller("/api")\n@Secured(SecurityRule.IS_AUTHENTICATED)\npublic class ProtectedController {\n\n    @Get("/protected")\n    public Map<String, Object> protectedEndpoint(Authentication authentication) {\n        // Zugangstoken-Informationen direkt aus Authentication abrufen\n        String scopes = (String) authentication.getAttributes().get("scope");\n        List<String> scopeList = scopes != null ? Arrays.asList(scopes.split(" ")) : List.of();\n\n        return Map.of(\n            "sub", authentication.getName(),\n            "client_id", authentication.getAttributes().get("client_id"),\n            "organization_id", authentication.getAttributes().get("organization_id"),\n            "scopes", scopeList,\n            "audience", authentication.getAttributes().get("aud")\n        );\n    }\n}\n'})})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},83597:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",metastring:'title="ProtectedResource.java"',children:'import org.eclipse.microprofile.jwt.JsonWebToken;\nimport jakarta.inject.Inject;\nimport jakarta.ws.rs.GET;\nimport jakarta.ws.rs.Path;\nimport jakarta.ws.rs.Produces;\nimport jakarta.ws.rs.core.MediaType;\nimport jakarta.ws.rs.core.Context;\nimport jakarta.ws.rs.container.ContainerRequestContext;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\n\n@Path("/api")\npublic class ProtectedResource {\n\n    @Inject\n    JsonWebToken jwt;\n\n    @GET\n    @Path("/protected")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Map<String, Object> protectedEndpoint(@Context ContainerRequestContext requestContext) {\n        // Zugriff auf das JWT direkt \xfcber Injection oder Kontext\n        JsonWebToken token = (JsonWebToken) requestContext.getProperty("auth");\n        if (token == null) {\n            token = jwt; // R\xfcckgriff auf injiziertes JWT\n        }\n\n        String scopes = token.getClaim("scope");\n        List<String> scopeList = scopes != null ? Arrays.asList(scopes.split(" ")) : List.of();\n\n        return Map.of(\n            "sub", token.getSubject(),\n            "client_id", token.<String>getClaim("client_id"),\n            "organization_id", token.<String>getClaim("organization_id"),\n            "scopes", scopeList,\n            "audience", token.getAudience()\n        );\n    }\n}\n'})})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},59391:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",metastring:'title="ProtectedController.java"',children:'import org.springframework.security.core.annotation.AuthenticationPrincipal;\nimport org.springframework.security.oauth2.jwt.Jwt;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\n\n@RestController\npublic class ProtectedController {\n\n    @GetMapping("/api/protected")\n    public Map<String, Object> protectedEndpoint(@AuthenticationPrincipal Jwt jwt) {\n        // Zugangstoken-Informationen direkt aus dem JWT abrufen\n        String scopes = jwt.getClaimAsString("scope");\n        List<String> scopeList = scopes != null ? Arrays.asList(scopes.split(" ")) : List.of();\n\n        return Map.of(\n            "sub", jwt.getSubject(),\n            "client_id", jwt.getClaimAsString("client_id"),\n            "organization_id", jwt.getClaimAsString("organization_id"),\n            "scopes", scopeList,\n            "audience", jwt.getAudience()\n        );\n    }\n}\n'})})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},93321:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",metastring:'title="MainVerticle.java"',children:'import io.vertx.core.AbstractVerticle;\nimport io.vertx.core.Promise;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.ext.web.Router;\nimport io.vertx.ext.web.RoutingContext;\n\npublic class MainVerticle extends AbstractVerticle {\n\n    @Override\n    public void start(Promise<Void> startPromise) throws Exception {\n        Router router = Router.router(vertx);\n\n        // Middleware auf gesch\xfctzte Routen anwenden\n        router.route("/api/protected*").handler(new JwtAuthHandler(vertx));\n        router.get("/api/protected").handler(this::protectedEndpoint);\n\n        vertx.createHttpServer()\n            .requestHandler(router)\n            .listen(8080, result -> {\n                if (result.succeeded()) {\n                    startPromise.complete();\n                } else {\n                    startPromise.fail(result.cause());\n                }\n            });\n    }\n\n    private void protectedEndpoint(RoutingContext context) {\n        // Zugriff auf das JWT-Prinzipal direkt aus dem Kontext\n        JsonObject principal = context.get("auth");\n        if (principal == null) {\n            context.response()\n                .setStatusCode(500)\n                .putHeader("Content-Type", "application/json")\n                .end("{\\"error\\": \\"JWT principal not found\\"}");\n            return;\n        }\n\n        String scopes = principal.getString("scope");\n        JsonObject response = new JsonObject()\n            .put("sub", principal.getString("sub"))\n            .put("client_id", principal.getString("client_id"))\n            .put("organization_id", principal.getString("organization_id"))\n            .put("scopes", scopes != null ? scopes.split(" ") : new String[0])\n            .put("audience", principal.getJsonArray("aud"));\n\n        context.response()\n            .putHeader("Content-Type", "application/json")\n            .end(response.encode());\n    }\n}\n'})})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},89739:(e,n,t)=>{t.d(n,{Ay:()=>f,RM:()=>g});var r=t(25105),i=t(79621),s=t(33435),a=t(38552),o=t(22002);function c(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="auth-middleware.ts"',children:"import { Request, Response, NextFunction } from 'express';\nimport { validateJwt, createAuthInfo } from './jwt-validator.js';\n\n// Erweiterung der Express Request-Schnittstelle um auth\ndeclare global {\n  namespace Express {\n    interface Request {\n      auth?: AuthInfo;\n    }\n  }\n}\n\nexport async function verifyAccessToken(req: Request, res: Response, next: NextFunction) {\n  try {\n    const token = extractBearerTokenFromHeaders(req.headers);\n    const payload = await validateJwt(token);\n\n    // Auth-Informationen im Request f\xfcr generische Nutzung speichern\n    req.auth = createAuthInfo(payload);\n\n    next();\n  } catch (err: any) {\n    return res.status(err.status ?? 401).json({ error: err.message });\n  }\n}\n"})})}function u(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="auth-middleware.ts"',children:"import { FastifyRequest, FastifyReply } from 'fastify';\nimport { validateJwt, createAuthInfo } from './jwt-validator.js';\n\n// Fastify Request-Interface erweitern, um auth einzuschlie\xdfen\ndeclare module 'fastify' {\n  interface FastifyRequest {\n    auth?: AuthInfo;\n  }\n}\n\nexport async function fastifyVerifyAccessToken(request: FastifyRequest, reply: FastifyReply) {\n  try {\n    const token = extractBearerTokenFromHeaders(request.headers);\n    const payload = await validateJwt(token);\n\n    // Auth-Informationen im Request f\xfcr generische Nutzung speichern\n    request.auth = createAuthInfo(payload);\n  } catch (err: any) {\n    reply.code(err.status ?? 401).send({ error: err.message });\n  }\n}\n"})})}function d(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="auth-middleware.ts"',children:"import { Request, ResponseToolkit } from '@hapi/hapi';\nimport { validateJwt, createAuthInfo } from './jwt-validator.js';\n\nexport async function hapiVerifyAccessToken(request: Request, h: ResponseToolkit) {\n  try {\n    const token = extractBearerTokenFromHeaders(request.headers);\n    const payload = await validateJwt(token);\n\n    // Auth-Informationen im request.app f\xfcr generische Nutzung speichern\n    request.app.auth = createAuthInfo(payload);\n\n    return h.continue;\n  } catch (err: any) {\n    return h\n      .response({ error: err.message })\n      .code(err.status ?? 401)\n      .takeover();\n  }\n}\n"})})}function l(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="auth-middleware.ts"',children:"import { Context, Next } from 'koa';\nimport { validateJwt, createAuthInfo } from './jwt-validator.js';\n\nexport async function koaVerifyAccessToken(ctx: Context, next: Next) {\n  try {\n    const token = extractBearerTokenFromHeaders(ctx.request.headers);\n    const payload = await validateJwt(token);\n\n    // Auth-Informationen im State f\xfcr generische Nutzung speichern\n    ctx.state.auth = createAuthInfo(payload);\n\n    await next();\n  } catch (err: any) {\n    ctx.status = err.status ?? 401;\n    ctx.body = { error: err.message };\n  }\n}\n"})})}function p(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="access-token.guard.ts"',children:"import {\n  Injectable,\n  CanActivate,\n  ExecutionContext,\n  UnauthorizedException,\n  ForbiddenException,\n} from '@nestjs/common';\nimport { validateJwt, createAuthInfo } from './jwt-validator.js';\n\n@Injectable()\nexport class AccessTokenGuard implements CanActivate {\n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    const req = context.switchToHttp().getRequest();\n\n    try {\n      const token = extractBearerTokenFromHeaders(req.headers);\n      const payload = await validateJwt(token);\n\n      // Auth-Informationen im Request f\xfcr generische Nutzung speichern\n      req.auth = createAuthInfo(payload);\n\n      return true;\n    } catch (err: any) {\n      if (err.status === 401) throw new UnauthorizedException(err.message);\n      throw new ForbiddenException(err.message);\n    }\n  }\n}\n"})})}const h=Object.freeze({express:(0,r.jsx)((function(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}),{}),fastify:(0,r.jsx)((function(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}),{}),hapi:(0,r.jsx)((function(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}),{}),koa:(0,r.jsx)((function(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}),{}),nestjs:(0,r.jsx)((function(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}),{})}),g=[];function m(e){const n={a:"a",code:"code",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Wir verwenden ",(0,r.jsx)(n.a,{href:"https://github.com/panva/jose",children:"jose"})," in diesem Beispiel, um das JWT zu validieren. Installiere es, falls du es noch nicht getan hast:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install jose\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Oder verwende deinen bevorzugten Paketmanager (z. B. ",(0,r.jsx)(n.code,{children:"pnpm"})," oder ",(0,r.jsx)(n.code,{children:"yarn"}),")."]}),"\n",(0,r.jsx)(n.p,{children:"F\xfcge zun\xe4chst diese gemeinsamen Hilfsfunktionen hinzu, um die JWT-Validierung zu handhaben:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="jwt-validator.ts"',children:"import { createRemoteJWKSet, jwtVerify, JWTPayload } from 'jose';\nimport { AuthInfo, AuthorizationError } from './auth-middleware.js';\n\nconst jwks = createRemoteJWKSet(new URL(JWKS_URI));\n\nexport async function validateJwt(token: string): Promise<JWTPayload> {\n  const { payload } = await jwtVerify(token, jwks, {\n    issuer: ISSUER,\n  });\n\n  verifyPayload(payload);\n  return payload;\n}\n\nexport function createAuthInfo(payload: JWTPayload): AuthInfo {\n  const scopes = (payload.scope as string)?.split(' ') ?? [];\n  const audience = Array.isArray(payload.aud) ? payload.aud : payload.aud ? [payload.aud] : [];\n\n  return new AuthInfo(\n    payload.sub!,\n    payload.client_id as string,\n    payload.organization_id as string,\n    scopes,\n    audience\n  );\n}\n\nfunction verifyPayload(payload: JWTPayload): void {\n  // Implementiere hier deine Verifizierungslogik basierend auf dem Berechtigungsmodell\n  // Dies wird im Abschnitt zu den Berechtigungsmodellen unten gezeigt\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Implementiere dann das Middleware, um das Zugangstoken zu \xfcberpr\xfcfen:"}),"\n",e.framework?h[e.framework]:(0,r.jsx)(o.A,{groupId:"api-framework",children:Object.entries(h).map((([e,n])=>(0,r.jsx)(a.A,{value:e,label:(0,s.My)(e),children:n},e)))}),"\n",(0,r.jsxs)(n.p,{children:["Entsprechend deinem Berechtigungsmodell implementiere die passende Verifizierungslogik in ",(0,r.jsx)(n.code,{children:"jwt-validator.ts"}),":"]}),"\n",(0,r.jsxs)(o.A,{groupId:"permission-models",children:[(0,r.jsx)(a.A,{value:"global-api-resources",label:"Globale API-Ressourcen",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="jwt-validator.ts"',children:"function verifyPayload(payload: JWTPayload): void {\n  // \xdcberpr\xfcfe, ob der Audience-Anspruch mit deinem API-Ressourcenindikator \xfcbereinstimmt\n  const audiences = Array.isArray(payload.aud) ? payload.aud : payload.aud ? [payload.aud] : [];\n  if (!audiences.includes('https://your-api-resource-indicator')) {\n    throw new AuthorizationError('Ung\xfcltige Zielgruppe (audience)');\n  }\n\n  // \xdcberpr\xfcfe erforderliche Berechtigungen f\xfcr globale API-Ressourcen\n  const requiredScopes = ['api:read', 'api:write']; // Ersetze durch deine tats\xe4chlich erforderlichen Berechtigungen\n  const scopes = (payload.scope as string)?.split(' ') ?? [];\n  if (!requiredScopes.every((scope) => scopes.includes(scope))) {\n    throw new AuthorizationError('Unzureichende Berechtigung (scope)');\n  }\n}\n"})})}),(0,r.jsx)(a.A,{value:"organization-permissions",label:"Organisation (nicht-API) Berechtigungen",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="jwt-validator.ts"',children:"function verifyPayload(payload: JWTPayload): void {\n  // \xdcberpr\xfcfe, ob der Audience-Anspruch dem Organisationsformat entspricht\n  const audiences = Array.isArray(payload.aud) ? payload.aud : payload.aud ? [payload.aud] : [];\n  const hasOrgAudience = audiences.some((aud) => aud.startsWith('urn:logto:organization:'));\n\n  if (!hasOrgAudience) {\n    throw new AuthorizationError('Ung\xfcltige Zielgruppe f\xfcr Organisationsberechtigungen');\n  }\n\n  // \xdcberpr\xfcfe, ob die Organisations-ID mit dem Kontext \xfcbereinstimmt (du musst dies ggf. aus dem Request-Kontext extrahieren)\n  const expectedOrgId = 'your-organization-id'; // Aus dem Request-Kontext extrahieren\n  const expectedAud = `urn:logto:organization:${expectedOrgId}`;\n  if (!audiences.includes(expectedAud)) {\n    throw new AuthorizationError('Organisations-ID stimmt nicht \xfcberein');\n  }\n\n  // \xdcberpr\xfcfe erforderliche Organisationsberechtigungen\n  const requiredScopes = ['invite:users', 'manage:settings']; // Ersetze durch deine tats\xe4chlich erforderlichen Berechtigungen\n  const scopes = (payload.scope as string)?.split(' ') ?? [];\n  if (!requiredScopes.every((scope) => scopes.includes(scope))) {\n    throw new AuthorizationError('Unzureichende Organisationsberechtigung (scope)');\n  }\n}\n"})})}),(0,r.jsx)(a.A,{value:"organization-level-api-resources",label:"Organisationsbezogene API-Ressourcen",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="jwt-validator.ts"',children:"function verifyPayload(payload: JWTPayload): void {\n  // \xdcberpr\xfcfe, ob der Audience-Anspruch mit deinem API-Ressourcenindikator \xfcbereinstimmt\n  const audiences = Array.isArray(payload.aud) ? payload.aud : payload.aud ? [payload.aud] : [];\n  if (!audiences.includes('https://your-api-resource-indicator')) {\n    throw new AuthorizationError('Ung\xfcltige Zielgruppe f\xfcr organisationsbezogene API-Ressourcen');\n  }\n\n  // \xdcberpr\xfcfe, ob die Organisations-ID mit dem Kontext \xfcbereinstimmt (du musst dies ggf. aus dem Request-Kontext extrahieren)\n  const expectedOrgId = 'your-organization-id'; // Aus dem Request-Kontext extrahieren\n  const orgId = payload.organization_id as string;\n  if (expectedOrgId !== orgId) {\n    throw new AuthorizationError('Organisations-ID stimmt nicht \xfcberein');\n  }\n\n  // \xdcberpr\xfcfe erforderliche Berechtigungen f\xfcr organisationsbezogene API-Ressourcen\n  const requiredScopes = ['api:read', 'api:write']; // Ersetze durch deine tats\xe4chlich erforderlichen Berechtigungen\n  const scopes = (payload.scope as string)?.split(' ') ?? [];\n  if (!requiredScopes.every((scope) => scopes.includes(scope))) {\n    throw new AuthorizationError('Unzureichende organisationsbezogene API-Berechtigungen (scope)');\n  }\n}\n"})})})]})]})}function f(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}},94612:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="auth-middleware.ts"',children:"import { IncomingHttpHeaders } from 'http';\n\nconst JWKS_URI = 'https://your-tenant.logto.app/oidc/jwks';\nconst ISSUER = 'https://your-tenant.logto.app/oidc';\n\nexport class AuthInfo {\n  constructor(\n    public sub: string,\n    public clientId?: string,\n    public organizationId?: string,\n    public scopes: string[] = [],\n    public audience: string[] = []\n  ) {}\n}\n\nexport class AuthorizationError extends Error {\n  name = 'AuthorizationError';\n  constructor(\n    message: string,\n    public status = 403\n  ) {\n    super(message);\n  }\n}\n\nexport function extractBearerTokenFromHeaders({ authorization }: IncomingHttpHeaders): string {\n  const bearerPrefix = 'Bearer ';\n\n  if (!authorization) {\n    throw new AuthorizationError('Authorization-Header fehlt', 401);\n  }\n\n  if (!authorization.startsWith(bearerPrefix)) {\n    throw new AuthorizationError(`Authorization-Header muss mit \"${bearerPrefix}\" beginnen`, 401);\n  }\n\n  return authorization.slice(bearerPrefix.length);\n}\n"})})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},14167:(e,n,t)=>{t.d(n,{Ay:()=>g,RM:()=>p});var r=t(25105),i=t(79621),s=t(33435),a=t(38552),o=t(22002);function c(e){const n={code:"code",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",metastring:'title="app/Http/Middleware/VerifyAccessToken.php"',children:"<?php\n\nnamespace App\\Http\\Middleware;\n\nuse Closure;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Http\\Response;\n\nclass VerifyAccessToken\n{\n    use AuthHelpers;\n\n    public function handle(Request $request, Closure $next): Response\n    {\n        try {\n            $token = $this->extractBearerToken($request->headers->all());\n            $payload = JwtValidator::validateJwt($token);\n\n            // Auth-Informationen in den Request-Attributen f\xfcr generische Nutzung speichern\n            $request->attributes->set('auth', JwtValidator::createAuthInfo($payload));\n\n            return $next($request);\n\n        } catch (AuthorizationException $e) {\n            return response()->json(['error' => $e->getMessage()], $e->statusCode);\n        }\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Registriere die Middleware in ",(0,r.jsx)(n.code,{children:"app/Http/Kernel.php"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",metastring:'title="app/Http/Kernel.php"',children:"protected $middlewareAliases = [\n    // ... andere Middleware\n    'auth.token' => \\App\\Http\\Middleware\\VerifyAccessToken::class,\n];\n"})})]})}function u(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",metastring:'title="src/Middleware/JwtMiddleware.php"',children:"<?php\n\nnamespace App\\Middleware;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Slim\\Psr7\\Response;\n\nclass JwtMiddleware implements MiddlewareInterface\n{\n    use AuthHelpers;\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface\n    {\n        try {\n            $headers = $request->getHeaders();\n            $token = $this->extractBearerToken($headers);\n            $payload = JwtValidator::validateJwt($token);\n\n            // Authentifizierungsinformationen in den Request-Attributen f\xfcr generische Nutzung speichern\n            $request = $request->withAttribute('auth', JwtValidator::createAuthInfo($payload));\n\n            return $handler->handle($request);\n\n        } catch (AuthorizationException $e) {\n            $response = new Response();\n            $response->getBody()->write(json_encode(['error' => $e->getMessage()]));\n            return $response\n                ->withHeader('Content-Type', 'application/json')\n                ->withStatus($e->statusCode);\n        }\n    }\n}\n"})})}function d(e){const n={code:"code",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",metastring:'title="src/Security/JwtAuthenticator.php"',children:"<?php\n\nnamespace App\\Security;\n\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface;\nuse Symfony\\Component\\Security\\Core\\Exception\\AuthenticationException;\nuse Symfony\\Component\\Security\\Http\\Authenticator\\AbstractAuthenticator;\nuse Symfony\\Component\\Security\\Http\\Authenticator\\Passport\\Badge\\UserBadge;\nuse Symfony\\Component\\Security\\Http\\Authenticator\\Passport\\Passport;\nuse Symfony\\Component\\Security\\Http\\Authenticator\\Passport\\SelfValidatingPassport;\n\nclass JwtAuthenticator extends AbstractAuthenticator\n{\n    use AuthHelpers;\n\n    public function supports(Request $request): ?bool\n    {\n        return $request->headers->has('authorization');\n    }\n\n    public function authenticate(Request $request): Passport\n    {\n        try {\n            $token = $this->extractBearerToken($request->headers->all());\n            $payload = JwtValidator::validateJwt($token);\n            $authInfo = JwtValidator::createAuthInfo($payload);\n\n            // Auth-Informationen in den Request-Attributen f\xfcr generische Nutzung speichern\n            $request->attributes->set('auth', $authInfo);\n\n            return new SelfValidatingPassport(new UserBadge($payload['sub']));\n\n        } catch (AuthorizationException $e) {\n            throw new AuthenticationException($e->getMessage());\n        }\n    }\n\n    public function onAuthenticationSuccess(Request $request, TokenInterface $token, string $firewallName): ?Response\n    {\n        return null; // Weiter zum Controller\n    }\n\n    public function onAuthenticationFailure(Request $request, AuthenticationException $exception): ?Response\n    {\n        return new JsonResponse(['error' => $exception->getMessage()], Response::HTTP_UNAUTHORIZED);\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Konfiguriere die Sicherheit in ",(0,r.jsx)(n.code,{children:"config/packages/security.yaml"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:'title="config/packages/security.yaml"',children:"security:\n  firewalls:\n    api:\n      pattern: ^/api/protected\n      stateless: true\n      custom_authenticators:\n        - App\\Security\\JwtAuthenticator\n"})})]})}const l=Object.freeze({laravel:(0,r.jsx)((function(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}),{}),symfony:(0,r.jsx)((function(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}),{}),slim:(0,r.jsx)((function(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}),{})}),p=[];function h(e){const n={a:"a",code:"code",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Wir verwenden ",(0,r.jsx)(n.a,{href:"https://github.com/firebase/php-jwt",children:"firebase/php-jwt"}),", um JWTs zu validieren. Installiere es mit Composer:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"composer require firebase/php-jwt\n"})}),"\n",(0,r.jsx)(n.p,{children:"F\xfcge zun\xe4chst diese gemeinsamen Hilfsfunktionen hinzu, um die JWT-Validierung zu behandeln:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",metastring:'title="JwtValidator.php"',children:"<?php\n\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\JWK;\nuse Firebase\\JWT\\Key;\n\nclass JwtValidator\n{\n    use AuthHelpers;\n\n    private static ?array $jwks = null;\n\n    public static function fetchJwks(): array\n    {\n        if (self::$jwks === null) {\n            $jwksData = file_get_contents(AuthConstants::JWKS_URI);\n            if ($jwksData === false) {\n                throw new AuthorizationException('Fehler beim Abrufen der JWKS', 401);\n            }\n\n            self::$jwks = json_decode($jwksData, true);\n        }\n\n        return self::$jwks;\n    }\n\n    public static function validateJwt(string $token): array\n    {\n        try {\n            $jwks = self::fetchJwks();\n            $keys = JWK::parseKeySet($jwks);\n\n            $decoded = JWT::decode($token, $keys);\n            $payload = (array) $decoded;\n\n            // Aussteller (Issuer) \xfcberpr\xfcfen\n            if (($payload['iss'] ?? '') !== AuthConstants::ISSUER) {\n                throw new AuthorizationException('Ung\xfcltiger Aussteller', 401);\n            }\n\n            self::verifyPayload($payload);\n            return $payload;\n\n        } catch (AuthorizationException $e) {\n            throw $e;\n        } catch (Exception $e) {\n            throw new AuthorizationException('Ung\xfcltiges Token: ' . $e->getMessage(), 401);\n        }\n    }\n\n    public static function createAuthInfo(array $payload): AuthInfo\n    {\n        $scopes = !empty($payload['scope']) ? explode(' ', $payload['scope']) : [];\n        $audience = $payload['aud'] ?? [];\n\n        if (is_string($audience)) {\n            $audience = [$audience];\n        }\n\n        return new AuthInfo(\n            sub: $payload['sub'],\n            clientId: $payload['client_id'] ?? null,\n            organizationId: $payload['organization_id'] ?? null,\n            scopes: $scopes,\n            audience: $audience\n        );\n    }\n\n    private static function verifyPayload(array $payload): void\n    {\n        // Implementiere hier deine \xdcberpr\xfcfungslogik basierend auf dem Berechtigungsmodell\n        // Dies wird im Abschnitt zu den Berechtigungsmodellen unten gezeigt\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Implementiere dann das Middleware, um das Zugangstoken zu \xfcberpr\xfcfen:"}),"\n",e.framework?l[e.framework]:(0,r.jsx)(o.A,{groupId:"api-framework",children:Object.entries(l).map((([e,n])=>(0,r.jsx)(a.A,{value:e,label:(0,s.My)(e),children:n},e)))}),"\n",(0,r.jsxs)(n.p,{children:["Entsprechend deinem Berechtigungsmodell implementiere die passende \xdcberpr\xfcfungslogik in ",(0,r.jsx)(n.code,{children:"JwtValidator"}),":"]}),"\n",(0,r.jsxs)(o.A,{groupId:"permission-models",children:[(0,r.jsx)(a.A,{value:"global-api-resources",label:"Globale API-Ressourcen",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",metastring:'title="JwtValidator.php"',children:"private static function verifyPayload(array $payload): void\n{\n    // \xdcberpr\xfcfe, ob der Audience-Anspruch (audience claim) mit deinem API-Ressourcenindikator \xfcbereinstimmt\n    $audiences = $payload['aud'] ?? [];\n    if (is_string($audiences)) {\n        $audiences = [$audiences];\n    }\n\n    if (!in_array('https://your-api-resource-indicator', $audiences)) {\n        throw new AuthorizationException('Ung\xfcltige Zielgruppe');\n    }\n\n    // \xdcberpr\xfcfe erforderliche Berechtigungen (Scopes) f\xfcr globale API-Ressourcen\n    $requiredScopes = ['api:read', 'api:write']; // Ersetze dies durch deine tats\xe4chlich erforderlichen Berechtigungen\n    $scopes = !empty($payload['scope']) ? explode(' ', $payload['scope']) : [];\n\n    foreach ($requiredScopes as $scope) {\n        if (!in_array($scope, $scopes)) {\n            throw new AuthorizationException('Unzureichende Berechtigung');\n        }\n    }\n}\n"})})}),(0,r.jsx)(a.A,{value:"organization-permissions",label:"Organisations-(Nicht-API)-Berechtigungen",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",metastring:'title="JwtValidator.php"',children:"private static function verifyPayload(array $payload): void\n{\n    // \xdcberpr\xfcfe, ob der Audience-Anspruch dem Organisationsformat entspricht\n    $audiences = $payload['aud'] ?? [];\n    if (is_string($audiences)) {\n        $audiences = [$audiences];\n    }\n\n    $hasOrgAudience = false;\n    foreach ($audiences as $aud) {\n        if (str_starts_with($aud, 'urn:logto:organization:')) {\n            $hasOrgAudience = true;\n            break;\n        }\n    }\n\n    if (!$hasOrgAudience) {\n        throw new AuthorizationException('Ung\xfcltige Zielgruppe f\xfcr Organisationsberechtigungen');\n    }\n\n    // \xdcberpr\xfcfe, ob die Organisations-ID mit dem Kontext \xfcbereinstimmt (dies musst du ggf. aus dem Request-Kontext extrahieren)\n    $expectedOrgId = 'your-organization-id'; // Aus dem Request-Kontext extrahieren\n    $expectedAud = \"urn:logto:organization:{$expectedOrgId}\";\n    if (!in_array($expectedAud, $audiences)) {\n        throw new AuthorizationException('Organisations-ID stimmt nicht \xfcberein');\n    }\n\n    // \xdcberpr\xfcfe erforderliche Organisations-Berechtigungen (Scopes)\n    $requiredScopes = ['invite:users', 'manage:settings']; // Ersetze dies durch deine tats\xe4chlich erforderlichen Berechtigungen\n    $scopes = !empty($payload['scope']) ? explode(' ', $payload['scope']) : [];\n\n    foreach ($requiredScopes as $scope) {\n        if (!in_array($scope, $scopes)) {\n            throw new AuthorizationException('Unzureichende Organisationsberechtigung');\n        }\n    }\n}\n"})})}),(0,r.jsx)(a.A,{value:"organization-level-api-resources",label:"Organisationsbezogene API-Ressourcen",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",metastring:'title="JwtValidator.php"',children:"private static function verifyPayload(array $payload): void\n{\n    // \xdcberpr\xfcfe, ob der Audience-Anspruch (audience claim) mit deinem API-Ressourcenindikator \xfcbereinstimmt\n    $audiences = $payload['aud'] ?? [];\n    if (is_string($audiences)) {\n        $audiences = [$audiences];\n    }\n\n    if (!in_array('https://your-api-resource-indicator', $audiences)) {\n        throw new AuthorizationException('Ung\xfcltige Zielgruppe f\xfcr organisationsbezogene API-Ressourcen');\n    }\n\n    // \xdcberpr\xfcfe, ob die Organisations-ID mit dem Kontext \xfcbereinstimmt (dies musst du ggf. aus dem Request-Kontext extrahieren)\n    $expectedOrgId = 'your-organization-id'; // Aus dem Request-Kontext extrahieren\n    $orgId = $payload['organization_id'] ?? null;\n    if ($expectedOrgId !== $orgId) {\n        throw new AuthorizationException('Organisations-ID stimmt nicht \xfcberein');\n    }\n\n    // \xdcberpr\xfcfe erforderliche Berechtigungen (Scopes) f\xfcr organisationsbezogene API-Ressourcen\n    $requiredScopes = ['api:read', 'api:write']; // Ersetze dies durch deine tats\xe4chlich erforderlichen Berechtigungen\n    $scopes = !empty($payload['scope']) ? explode(' ', $payload['scope']) : [];\n\n    foreach ($requiredScopes as $scope) {\n        if (!in_array($scope, $scopes)) {\n            throw new AuthorizationException('Unzureichende Berechtigungen f\xfcr organisationsbezogene API-Ressourcen');\n        }\n    }\n}\n"})})})]})]})}function g(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},39365:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",metastring:'title="AuthConstants.php"',children:"<?php\n\nclass AuthConstants\n{\n    public const JWKS_URI = 'https://your-tenant.logto.app/oidc/jwks';\n    public const ISSUER = 'https://your-tenant.logto.app/oidc';\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",metastring:'title="AuthInfo.php"',children:"<?php\n\nclass AuthInfo\n{\n    public function __construct(\n        public readonly string $sub,\n        public readonly ?string $clientId = null,\n        public readonly ?string $organizationId = null,\n        public readonly array $scopes = [],\n        public readonly array $audience = []\n    ) {}\n\n    public function toArray(): array\n    {\n        return [\n            'sub' => $this->sub,\n            'client_id' => $this->clientId,\n            'organization_id' => $this->organizationId,\n            'scopes' => $this->scopes,\n            'audience' => $this->audience,\n        ];\n    }\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",metastring:'title="AuthorizationException.php"',children:"<?php\n\nclass AuthorizationException extends Exception\n{\n    public function __construct(\n        string $message,\n        public readonly int $statusCode = 403\n    ) {\n        parent::__construct($message);\n    }\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",metastring:'title="AuthHelpers.php"',children:"<?php\n\ntrait AuthHelpers\n{\n    protected function extractBearerToken(array $headers): string\n    {\n        $authorization = $headers['authorization'][0] ?? $headers['Authorization'][0] ?? null;\n\n        if (!$authorization) {\n            throw new AuthorizationException('Autorisierungs-Header fehlt (Authorization header is missing)', 401);\n        }\n\n        if (!str_starts_with($authorization, 'Bearer ')) {\n            throw new AuthorizationException('Autorisierungs-Header muss mit \"Bearer \" beginnen (Authorization header must start with \"Bearer \")', 401);\n        }\n\n        return substr($authorization, 7); // Entfernt das Pr\xe4fix 'Bearer ' (Remove 'Bearer ' prefix)\n    }\n}\n"})})]})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},33478:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",metastring:'title="routes/api.php"',children:"<?php\n\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Route;\n\nRoute::middleware('auth.token')->group(function () {\n    Route::get('/api/protected', function (Request $request) {\n        // Zugriff auf Authentifizierungsinformationen aus den Request-Attributen\n        $auth = $request->attributes->get('auth');\n        return ['auth' => $auth->toArray()];\n    });\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Oder mit Controllern:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",metastring:'title="app/Http/Controllers/Api/ProtectedController.php"',children:"<?php\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\n\nclass ProtectedController extends Controller\n{\n    public function __construct()\n    {\n        $this->middleware('auth.token');\n    }\n\n    public function index(Request $request)\n    {\n        // Zugriff auf Authentifizierungsinformationen aus den Request-Attributen\n        $auth = $request->attributes->get('auth');\n        return ['auth' => $auth->toArray()];\n    }\n\n    public function show(Request $request)\n    {\n        // Deine Logik f\xfcr den gesch\xfctzten Endpunkt\n        $auth = $request->attributes->get('auth');\n        return [\n            'auth' => $auth->toArray(),\n            'message' => 'Gesch\xfctzte Daten wurden erfolgreich abgerufen'\n        ];\n    }\n}\n"})})]})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},32964:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",metastring:'title="src/Controllers/ProtectedController.php"',children:"<?php\n\nnamespace App\\Controllers;\n\nuse Psr\\Http\\Message\\ResponseInterface as Response;\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\n\nclass ProtectedController\n{\n    public function index(Request $request, Response $response): Response\n    {\n        // Zugriff auf Authentifizierungsinformationen aus den Request-Attributen\n        $auth = $request->getAttribute('auth');\n        $response->getBody()->write(json_encode(['auth' => $auth->toArray()]));\n        return $response->withHeader('Content-Type', 'application/json');\n    }\n\n    public function detailed(Request $request, Response $response): Response\n    {\n        // Deine Logik f\xfcr den gesch\xfctzten Endpunkt\n        $auth = $request->getAttribute('auth');\n        $data = [\n            'auth' => $auth->toArray(),\n            'message' => 'Gesch\xfctzte Daten wurden erfolgreich abgerufen'\n        ];\n        $response->getBody()->write(json_encode($data));\n        return $response->withHeader('Content-Type', 'application/json');\n    }\n}\n"})})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},15142:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",metastring:'title="src/Controller/Api/ProtectedController.php"',children:"<?php\n\nnamespace App\\Controller\\Api;\n\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Component\\Security\\Http\\Attribute\\IsGranted;\n\n#[Route('/api/protected')]\n#[IsGranted('IS_AUTHENTICATED_FULLY')]\nclass ProtectedController extends AbstractController\n{\n    #[Route('', methods: ['GET'])]\n    public function index(Request $request): JsonResponse\n    {\n        // Zugriff auf Authentifizierungsinformationen aus den Request-Attributen\n        $auth = $request->attributes->get('auth');\n        return $this->json(['auth' => $auth->toArray()]);\n    }\n}\n"})})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},86881:(e,n,t)=>{t.d(n,{Ay:()=>m,RM:()=>h});var r=t(25105),i=t(79621),s=t(33435),a=t(38552),o=t(22002);function c(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",metastring:'title="auth_middleware.py"',children:"from django.http import JsonResponse\nfrom jwt_validator import validate_jwt, create_auth_info\n\ndef require_access_token(view_func):\n    def wrapper(request, *args, **kwargs):\n        try:\n            headers = {key.replace('HTTP_', '').replace('_', '-').lower(): value\n                      for key, value in request.META.items() if key.startswith('HTTP_')}\n\n            token = extract_bearer_token_from_headers(headers)\n            payload = validate_jwt(token)\n\n            # Auth-Informationen an die Anfrage anh\xe4ngen, um sie allgemein zu verwenden\n            request.auth = create_auth_info(payload)\n\n            return view_func(request, *args, **kwargs)\n\n        except AuthorizationError as e:\n            return JsonResponse({'error': str(e)}, status=e.status)\n\n    return wrapper\n"})})}function u(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",metastring:'title="auth_middleware.py"',children:"from rest_framework.authentication import TokenAuthentication\nfrom rest_framework import exceptions\nfrom jwt_validator import validate_jwt, create_auth_info\n\nclass AccessTokenAuthentication(TokenAuthentication):\n    keyword = 'Bearer'  # Verwende 'Bearer' statt 'Token'\n\n    def authenticate_credentials(self, key):\n        \"\"\"\n        Authentifiziere das Token, indem es als JWT validiert wird.\n        \"\"\"\n        try:\n            payload = validate_jwt(key)\n            auth_info = create_auth_info(payload)\n\n            # Erstelle ein benutzer\xe4hnliches Objekt, das Auth-Informationen f\xfcr generische Nutzung h\xe4lt\n            user = type('User', (), {\n                'auth': auth_info,\n                'is_authenticated': True,\n                'is_anonymous': False,\n                'is_active': True,\n            })()\n\n            return (user, key)\n\n        except AuthorizationError as e:\n            if e.status == 401:\n                raise exceptions.AuthenticationFailed(str(e))\n            else:  # 403\n                raise exceptions.PermissionDenied(str(e))\n"})})}function d(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",metastring:'title="auth_middleware.py"',children:"from fastapi import HTTPException, Depends\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom jwt_validator import validate_jwt, create_auth_info\n\nsecurity = HTTPBearer()\n\nasync def verify_access_token(credentials: HTTPAuthorizationCredentials = Depends(security)) -> AuthInfo:\n    try:\n        token = credentials.credentials\n        payload = validate_jwt(token)\n        return create_auth_info(payload)\n\n    except AuthorizationError as e:\n        raise HTTPException(status_code=e.status, detail=str(e))\n"})})}function l(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",metastring:'title="auth_middleware.py"',children:"from functools import wraps\nfrom flask import request, jsonify, g\nfrom jwt_validator import validate_jwt, create_auth_info\n\ndef verify_access_token(f):\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        try:\n            token = extract_bearer_token_from_headers(dict(request.headers))\n            payload = validate_jwt(token)\n\n            # Auth-Informationen im Flask-g-Objekt f\xfcr generische Nutzung speichern\n            g.auth = create_auth_info(payload)\n\n            return f(*args, **kwargs)\n\n        except AuthorizationError as e:\n            return jsonify({'error': str(e)}), e.status\n\n    return decorated_function\n"})})}const p=Object.freeze({fastapi:(0,r.jsx)((function(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}),{}),flask:(0,r.jsx)((function(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}),{}),django:(0,r.jsx)((function(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}),{}),"django-rest":(0,r.jsx)((function(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}),{})}),h=[];function g(e){const n={a:"a",code:"code",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Wir verwenden ",(0,r.jsx)(n.a,{href:"https://github.com/jpadilla/pyjwt",children:"PyJWT"}),", um JWTs zu validieren. Installiere es, falls du es noch nicht getan hast:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"pip install pyjwt[crypto]\n"})}),"\n",(0,r.jsx)(n.p,{children:"F\xfcge zun\xe4chst diese gemeinsamen Hilfsfunktionen hinzu, um die JWT-Validierung zu handhaben:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",metastring:'title="jwt_validator.py"',children:"import jwt\nfrom jwt import PyJWKClient\nfrom typing import Dict, Any\nfrom auth_middleware import AuthInfo, AuthorizationError, JWKS_URI, ISSUER\n\njwks_client = PyJWKClient(JWKS_URI)\n\ndef validate_jwt(token: str) -> Dict[str, Any]:\n    \"\"\"JWT validieren und Payload zur\xfcckgeben\"\"\"\n    try:\n        signing_key = jwks_client.get_signing_key_from_jwt(token)\n\n        payload = jwt.decode(\n            token,\n            signing_key.key,\n            algorithms=['RS256'],\n            issuer=ISSUER,\n            options={'verify_aud': False}  # Die Zielgruppe wird manuell \xfcberpr\xfcft\n        )\n\n        verify_payload(payload)\n        return payload\n\n    except jwt.InvalidTokenError as e:\n        raise AuthorizationError(f'Ung\xfcltiges Token: {str(e)}', 401)\n    except Exception as e:\n        raise AuthorizationError(f'Token-Validierung fehlgeschlagen: {str(e)}', 401)\n\ndef create_auth_info(payload: Dict[str, Any]) -> AuthInfo:\n    \"\"\"AuthInfo aus JWT-Payload erstellen\"\"\"\n    scopes = payload.get('scope', '').split(' ') if payload.get('scope') else []\n    audience = payload.get('aud', [])\n    if isinstance(audience, str):\n        audience = [audience]\n\n    return AuthInfo(\n        sub=payload.get('sub'),\n        client_id=payload.get('client_id'),\n        organization_id=payload.get('organization_id'),\n        scopes=scopes,\n        audience=audience\n    )\n\ndef verify_payload(payload: Dict[str, Any]) -> None:\n    \"\"\"Payload basierend auf Berechtigungsmodell \xfcberpr\xfcfen\"\"\"\n    # Implementiere hier deine \xdcberpr\xfcfungslogik basierend auf dem Berechtigungsmodell\n    # Dies wird im Abschnitt zu den Berechtigungsmodellen unten gezeigt\n    pass\n"})}),"\n",(0,r.jsx)(n.p,{children:"Implementiere anschlie\xdfend die Middleware, um das Zugangstoken zu \xfcberpr\xfcfen:"}),"\n",e.framework?p[e.framework]:(0,r.jsx)(o.A,{groupId:"api-framework",children:Object.entries(p).map((([e,n])=>(0,r.jsx)(a.A,{value:e,label:(0,s.My)(e),children:n},e)))}),"\n",(0,r.jsxs)(n.p,{children:["Implementiere gem\xe4\xdf deinem Berechtigungsmodell die entsprechende \xdcberpr\xfcfungslogik in ",(0,r.jsx)(n.code,{children:"jwt_validator.py"}),":"]}),"\n",(0,r.jsxs)(o.A,{groupId:"permission-models",children:[(0,r.jsx)(a.A,{value:"global-api-resources",label:"Globale API-Ressourcen",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",metastring:'title="jwt_validator.py"',children:"def verify_payload(payload: Dict[str, Any]) -> None:\n    \"\"\"Payload f\xfcr globale API-Ressourcen \xfcberpr\xfcfen\"\"\"\n    # \xdcberpr\xfcfe, ob der Audience-Claim mit deinem API-Ressourcenindikator \xfcbereinstimmt\n    audiences = payload.get('aud', [])\n    if isinstance(audiences, str):\n        audiences = [audiences]\n\n    if 'https://your-api-resource-indicator' not in audiences:\n        raise AuthorizationError('Ung\xfcltige Zielgruppe')\n\n    # \xdcberpr\xfcfe erforderliche Berechtigungen f\xfcr globale API-Ressourcen\n    required_scopes = ['api:read', 'api:write']  # Ersetze durch deine tats\xe4chlich ben\xf6tigten Berechtigungen\n    scopes = payload.get('scope', '').split(' ') if payload.get('scope') else []\n    if not all(scope in scopes for scope in required_scopes):\n        raise AuthorizationError('Unzureichende Berechtigung')\n"})})}),(0,r.jsx)(a.A,{value:"organization-permissions",label:"Organisation (nicht-API) Berechtigungen",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",metastring:'title="jwt_validator.py"',children:"def verify_payload(payload: Dict[str, Any]) -> None:\n    \"\"\"Payload f\xfcr Organisationsberechtigungen \xfcberpr\xfcfen\"\"\"\n    # \xdcberpr\xfcfe, ob der Audience-Claim dem Organisationsformat entspricht\n    audiences = payload.get('aud', [])\n    if isinstance(audiences, str):\n        audiences = [audiences]\n\n    has_org_audience = any(aud.startswith('urn:logto:organization:') for aud in audiences)\n    if not has_org_audience:\n        raise AuthorizationError('Ung\xfcltige Zielgruppe f\xfcr Organisationsberechtigungen')\n\n    # \xdcberpr\xfcfe, ob die Organisations-ID mit dem Kontext \xfcbereinstimmt (ggf. aus dem Request-Kontext extrahieren)\n    expected_org_id = 'your-organization-id'  # Aus dem Request-Kontext extrahieren\n    expected_aud = f'urn:logto:organization:{expected_org_id}'\n    if expected_aud not in audiences:\n        raise AuthorizationError('Organisations-ID stimmt nicht \xfcberein')\n\n    # \xdcberpr\xfcfe erforderliche Organisationsberechtigungen\n    required_scopes = ['invite:users', 'manage:settings']  # Ersetze durch deine tats\xe4chlich ben\xf6tigten Berechtigungen\n    scopes = payload.get('scope', '').split(' ') if payload.get('scope') else []\n    if not all(scope in scopes for scope in required_scopes):\n        raise AuthorizationError('Unzureichende Organisationsberechtigung')\n"})})}),(0,r.jsx)(a.A,{value:"organization-level-api-resources",label:"Organisationsbezogene API-Ressourcen",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",metastring:'title="jwt_validator.py"',children:"def verify_payload(payload: Dict[str, Any]) -> None:\n    \"\"\"Payload f\xfcr organisationsbezogene API-Ressourcen \xfcberpr\xfcfen\"\"\"\n    # \xdcberpr\xfcfe, ob der Audience-Claim mit deinem API-Ressourcenindikator \xfcbereinstimmt\n    audiences = payload.get('aud', [])\n    if isinstance(audiences, str):\n        audiences = [audiences]\n\n    if 'https://your-api-resource-indicator' not in audiences:\n        raise AuthorizationError('Ung\xfcltige Zielgruppe f\xfcr organisationsbezogene API-Ressourcen')\n\n    # \xdcberpr\xfcfe, ob die Organisations-ID mit dem Kontext \xfcbereinstimmt (ggf. aus dem Request-Kontext extrahieren)\n    expected_org_id = 'your-organization-id'  # Aus dem Request-Kontext extrahieren\n    org_id = payload.get('organization_id')\n    if expected_org_id != org_id:\n        raise AuthorizationError('Organisations-ID stimmt nicht \xfcberein')\n\n    # \xdcberpr\xfcfe erforderliche Berechtigungen f\xfcr organisationsbezogene API-Ressourcen\n    required_scopes = ['api:read', 'api:write']  # Ersetze durch deine tats\xe4chlich ben\xf6tigten Berechtigungen\n    scopes = payload.get('scope', '').split(' ') if payload.get('scope') else []\n    if not all(scope in scopes for scope in required_scopes):\n        raise AuthorizationError('Unzureichende organisationsbezogene API-Berechtigungen')\n"})})})]})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(g,{...e})}):g(e)}},23335:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",metastring:'title="auth_middleware.py"',children:"JWKS_URI = 'https://your-tenant.logto.app/oidc/jwks'\nISSUER = 'https://your-tenant.logto.app/oidc'\n\nclass AuthInfo:\n    def __init__(self, sub: str, client_id: str = None, organization_id: str = None,\n                 scopes: list = None, audience: list = None):\n        self.sub = sub\n        self.client_id = client_id\n        self.organization_id = organization_id\n        self.scopes = scopes or []\n        self.audience = audience or []\n\n    def to_dict(self):\n        return {\n            'sub': self.sub,\n            'client_id': self.client_id,\n            'organization_id': self.organization_id,\n            'scopes': self.scopes,\n            'audience': self.audience\n        }\n\nclass AuthorizationError(Exception):\n    def __init__(self, message: str, status: int = 403):\n        self.message = message\n        self.status = status\n        super().__init__(self.message)\n\ndef extract_bearer_token_from_headers(headers: dict) -> str:\n    \"\"\"\n    Extrahiere das Bearer-Token aus den HTTP-Headern.\n\n    Hinweis: FastAPI und Django REST Framework verf\xfcgen \xfcber eine eingebaute Token-Extraktion,\n    daher ist diese Funktion haupts\xe4chlich f\xfcr Flask und andere Frameworks gedacht.\n    \"\"\"\n    authorization = headers.get('authorization') or headers.get('Authorization')\n\n    if not authorization:\n        raise AuthorizationError('Authorization-Header fehlt', 401)\n\n    if not authorization.startswith('Bearer '):\n        raise AuthorizationError('Authorization-Header muss mit \"Bearer \" beginnen', 401)\n\n    return authorization[7:]  # Entferne das Pr\xe4fix 'Bearer '\n"})})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},77437:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",metastring:'title="views.py"',children:"from rest_framework.decorators import api_view, authentication_classes\nfrom rest_framework.response import Response\nfrom auth_middleware import AccessTokenAuthentication\n\n@api_view(['GET'])\n@authentication_classes([AccessTokenAuthentication])\ndef protected_view(request):\n    # Zugriff auf Authentifizierungsinformationen \xfcber request.user.auth\n    return Response({\"auth\": request.user.auth.to_dict()})\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Oder mit klassenbasierten Views:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",metastring:'title="views.py"',children:'from rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom auth_middleware import AccessTokenAuthentication\n\nclass ProtectedView(APIView):\n    authentication_classes = [AccessTokenAuthentication]\n\n    def get(self, request):\n        # Zugriff auf Authentifizierungsinformationen \xfcber request.user.auth\n        return Response({"auth": request.user.auth.to_dict()})\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",metastring:'title="urls.py"',children:"from django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('api/protected/', views.protected_view, name='protected'),\n    # Oder f\xfcr klassenbasierte Views:\n    # path('api/protected/', views.ProtectedView.as_view(), name='protected'),\n]\n"})})]})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},18588:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",metastring:'title="views.py"',children:'from django.http import JsonResponse\nfrom auth_middleware import require_access_token\n\n@require_access_token\ndef protected_view(request):\n    # Zugriff auf Authentifizierungsinformationen \xfcber request.auth\n    return JsonResponse({"auth": request.auth.to_dict()})\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",metastring:'title="urls.py"',children:"from django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('api/protected/', views.protected_view, name='protected'),\n]\n"})})]})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8675:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",metastring:'title="app.py"',children:'from fastapi import FastAPI, Depends\nfrom auth_middleware import verify_access_token, AuthInfo\n\napp = FastAPI()\n\n@app.get("/api/protected")\nasync def protected_endpoint(auth: AuthInfo = Depends(verify_access_token)):\n    # Greife direkt \xfcber den auth-Parameter auf Authentifizierungsinformationen zu\n    return {"auth": auth.to_dict()}\n'})})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},10074:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",metastring:'title="app.py"',children:"from flask import Flask, g, jsonify\nfrom auth_middleware import verify_access_token\n\napp = Flask(__name__)\n\n@app.route('/api/protected', methods=['GET'])\n@verify_access_token\ndef protected_endpoint():\n    # Zugriff auf Authentifizierungsinformationen aus g.auth\n    return jsonify({\"auth\": g.auth.to_dict()})\n"})})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},61633:(e,n,t)=>{t.d(n,{Ay:()=>g,RM:()=>p});var r=t(25105),i=t(79621),s=t(33435),a=t(38552),o=t(22002);function c(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="auth_helpers.rb"',children:"module GrapeAuthHelpers\n  include AuthHelpers\n\n  def authenticate_user!\n    begin\n      token = extract_bearer_token(request)\n      decoded_token = JwtValidator.validate_jwt(token)\n\n      # Auth-Informationen f\xfcr die allgemeine Verwendung speichern\n      @auth = JwtValidator.create_auth_info(decoded_token)\n\n    rescue AuthorizationError => e\n      error!({ error: e.message }, e.status)\n    rescue JWT::DecodeError, JWT::VerificationError, JWT::ExpiredSignature => e\n      error!({ error: 'Ung\xfcltiges Token' }, 401)\n    end\n  end\n\n  def auth\n    @auth\n  end\nend\n"})})}function u(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="app/controllers/concerns/jwt_authentication.rb"',children:"module JwtAuthentication\n  extend ActiveSupport::Concern\n  include AuthHelpers\n\n  included do\n    before_action :verify_access_token, only: [:protected_action] # F\xfcge spezifische Aktionen hinzu\n  end\n\n  private\n\n  def verify_access_token\n    begin\n      token = extract_bearer_token(request)\n      decoded_token = JwtValidator.validate_jwt(token)\n\n      # Auth-Informationen f\xfcr generische Nutzung speichern\n      @auth = JwtValidator.create_auth_info(decoded_token)\n\n    rescue AuthorizationError => e\n      render json: { error: e.message }, status: e.status\n    rescue JWT::DecodeError, JWT::VerificationError, JWT::ExpiredSignature => e\n      render json: { error: 'Ung\xfcltiges Token' }, status: 401\n    end\n  end\nend\n"})})}function d(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="auth_middleware.rb"',children:"class AuthMiddleware\n  include AuthHelpers\n\n  def initialize(app)\n    @app = app\n  end\n\n  def call(env)\n    request = Rack::Request.new(env)\n\n    # Sch\xfctze nur bestimmte Routen\n    if request.path.start_with?('/api/protected')\n      begin\n        token = extract_bearer_token(request)\n        decoded_token = JwtValidator.validate_jwt(token)\n\n        # Auth-Informationen im env f\xfcr generische Nutzung speichern\n        env['auth'] = JwtValidator.create_auth_info(decoded_token)\n\n      rescue AuthorizationError => e\n        return [e.status, { 'Content-Type' => 'application/json' }, [{ error: e.message }.to_json]]\n      rescue JWT::DecodeError, JWT::VerificationError, JWT::ExpiredSignature => e\n        return [401, { 'Content-Type' => 'application/json' }, [{ error: 'Ung\xfcltiges Token' }.to_json]]\n      end\n    end\n\n    @app.call(env)\n  end\nend\n"})})}const l=Object.freeze({rails:(0,r.jsx)((function(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}),{}),sinatra:(0,r.jsx)((function(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}),{}),grape:(0,r.jsx)((function(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}),{})}),p=[];function h(e){const n={a:"a",code:"code",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Wir verwenden das ",(0,r.jsx)(n.a,{href:"https://github.com/jwt/ruby-jwt",children:"jwt"})," Gem, um JWTs zu validieren. F\xfcge es zu deiner Gemfile hinzu:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="Gemfile"',children:"gem 'jwt'\n# net-http ist seit Ruby 2.7 Teil der Ruby-Standardbibliothek, muss nicht explizit hinzugef\xfcgt werden\n"})}),"\n",(0,r.jsx)(n.p,{children:"F\xfchre dann aus:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"bundle install\n"})}),"\n",(0,r.jsx)(n.p,{children:"F\xfcge zun\xe4chst diese gemeinsamen Hilfsfunktionen hinzu, um JWKS und Token-Validierung zu behandeln:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="jwt_validator.rb"',children:"require 'jwt'\nrequire 'net/http'\nrequire 'json'\n\nclass JwtValidator\n  include AuthHelpers\n\n  def self.fetch_jwks\n    @jwks ||= begin\n      uri = URI(AuthConstants::JWKS_URI)\n      response = Net::HTTP.get_response(uri)\n      raise AuthorizationError.new('Failed to fetch JWKS', 401) unless response.is_a?(Net::HTTPSuccess)\n\n      jwks_data = JSON.parse(response.body)\n      JWT::JWK::Set.new(jwks_data)\n    end\n  end\n\n  def self.validate_jwt(token)\n    jwks = fetch_jwks\n\n    # Die JWT-Bibliothek erkennt den Algorithmus automatisch aus dem JWKS\n    decoded_token = JWT.decode(token, nil, true, {\n      iss: AuthConstants::ISSUER,\n      verify_iss: true,\n      verify_aud: false, # Die Zielgruppe wird manuell anhand des Berechtigungsmodells \xfcberpr\xfcft\n      jwks: jwks\n    })[0]\n\n    verify_payload(decoded_token)\n    decoded_token\n  end\n\n  def self.create_auth_info(payload)\n    scopes = payload['scope']&.split(' ') || []\n    audience = payload['aud'] || []\n\n    AuthInfo.new(\n      payload['sub'],\n      payload['client_id'],\n      payload['organization_id'],\n      scopes,\n      audience\n    )\n  end\n\n  def self.verify_payload(payload)\n    # Implementiere hier deine \xdcberpr\xfcfungslogik basierend auf dem Berechtigungsmodell\n    # Dies wird im Abschnitt zu den Berechtigungsmodellen unten gezeigt\n  end\nend\n"})}),"\n",(0,r.jsx)(n.p,{children:"Implementiere anschlie\xdfend die Middleware, um das Zugangstoken zu \xfcberpr\xfcfen:"}),"\n",e.framework?l[e.framework]:(0,r.jsx)(o.A,{groupId:"api-framework",children:Object.entries(l).map((([e,n])=>(0,r.jsx)(a.A,{value:e,label:(0,s.My)(e),children:n},e)))}),"\n",(0,r.jsxs)(n.p,{children:["Entsprechend deinem Berechtigungsmodell implementiere die passende \xdcberpr\xfcfungslogik in ",(0,r.jsx)(n.code,{children:"JwtValidator"}),":"]}),"\n",(0,r.jsxs)(o.A,{groupId:"permission-models",children:[(0,r.jsx)(a.A,{value:"global-api-resources",label:"Globale API-Ressourcen",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="jwt_validator.rb"',children:"def self.verify_payload(payload)\n  # \xdcberpr\xfcfe, ob der Audience-Claim mit deinem API-Ressourcenindikator \xfcbereinstimmt\n  audiences = payload['aud'] || []\n  unless audiences.include?('https://your-api-resource-indicator')\n    raise AuthorizationError.new('Invalid audience')\n  end\n\n  # \xdcberpr\xfcfe erforderliche Berechtigungen f\xfcr globale API-Ressourcen\n  required_scopes = ['api:read', 'api:write'] # Ersetze durch deine tats\xe4chlich erforderlichen Berechtigungen\n  token_scopes = payload['scope']&.split(' ') || []\n\n  unless required_scopes.all? { |scope| token_scopes.include?(scope) }\n    raise AuthorizationError.new('Insufficient scope')\n  end\nend\n"})})}),(0,r.jsx)(a.A,{value:"organization-permissions",label:"Organisations-(Nicht-API)-Berechtigungen",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="jwt_validator.rb"',children:"def self.verify_payload(payload)\n  # \xdcberpr\xfcfe, ob der Audience-Claim dem Organisationsformat entspricht\n  audiences = payload['aud'] || []\n  has_org_audience = audiences.any? { |aud| aud.start_with?('urn:logto:organization:') }\n\n  unless has_org_audience\n    raise AuthorizationError.new('Invalid audience for organization permissions')\n  end\n\n  # \xdcberpr\xfcfe, ob die Organisations-ID mit dem Kontext \xfcbereinstimmt (dies musst du ggf. aus dem Request-Kontext extrahieren)\n  expected_org_id = 'your-organization-id' # Aus dem Request-Kontext extrahieren\n  expected_aud = \"urn:logto:organization:#{expected_org_id}\"\n  unless audiences.include?(expected_aud)\n    raise AuthorizationError.new('Organization ID mismatch')\n  end\n\n  # \xdcberpr\xfcfe erforderliche Organisationsberechtigungen\n  required_scopes = ['invite:users', 'manage:settings'] # Ersetze durch deine tats\xe4chlich erforderlichen Berechtigungen\n  token_scopes = payload['scope']&.split(' ') || []\n\n  unless required_scopes.all? { |scope| token_scopes.include?(scope) }\n    raise AuthorizationError.new('Insufficient organization scope')\n  end\nend\n"})})}),(0,r.jsx)(a.A,{value:"organization-level-api-resources",label:"Organisationsbezogene API-Ressourcen",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="jwt_validator.rb"',children:"def self.verify_payload(payload)\n  # \xdcberpr\xfcfe, ob der Audience-Claim mit deinem API-Ressourcenindikator \xfcbereinstimmt\n  audiences = payload['aud'] || []\n  unless audiences.include?('https://your-api-resource-indicator')\n    raise AuthorizationError.new('Invalid audience for organization-level API resources')\n  end\n\n  # \xdcberpr\xfcfe, ob die Organisations-ID mit dem Kontext \xfcbereinstimmt (dies musst du ggf. aus dem Request-Kontext extrahieren)\n  expected_org_id = 'your-organization-id' # Aus dem Request-Kontext extrahieren\n  org_id = payload['organization_id']\n  unless expected_org_id == org_id\n    raise AuthorizationError.new('Organization ID mismatch')\n  end\n\n  # \xdcberpr\xfcfe erforderliche Berechtigungen f\xfcr organisationsbezogene API-Ressourcen\n  required_scopes = ['api:read', 'api:write'] # Ersetze durch deine tats\xe4chlich erforderlichen Berechtigungen\n  token_scopes = payload['scope']&.split(' ') || []\n\n  unless required_scopes.all? { |scope| token_scopes.include?(scope) }\n    raise AuthorizationError.new('Insufficient organization-level API scopes')\n  end\nend\n"})})})]})]})}function g(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},93745:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="auth_constants.rb"',children:"module AuthConstants\n  JWKS_URI = 'https://your-tenant.logto.app/oidc/jwks'\n  ISSUER = 'https://your-tenant.logto.app/oidc'\nend\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="auth_info.rb"',children:"class AuthInfo\n  attr_accessor :sub, :client_id, :organization_id, :scopes, :audience\n\n  def initialize(sub, client_id = nil, organization_id = nil, scopes = [], audience = [])\n    @sub = sub\n    @client_id = client_id\n    @organization_id = organization_id\n    @scopes = scopes\n    @audience = audience\n  end\n\n  def to_h\n    {\n      sub: @sub,\n      client_id: @client_id,\n      organization_id: @organization_id,\n      scopes: @scopes,\n      audience: @audience\n    }\n  end\nend\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="authorization_error.rb"',children:"class AuthorizationError < StandardError\n  attr_reader :status\n\n  def initialize(message, status = 403)\n    super(message)\n    @status = status\n  end\nend\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="auth_helpers.rb"',children:"module AuthHelpers\n  def extract_bearer_token(request)\n    authorization = request.headers['Authorization']\n\n    raise AuthorizationError.new('Authorization header fehlt', 401) unless authorization\n    raise AuthorizationError.new('Authorization header muss mit \"Bearer \" beginnen', 401) unless authorization.start_with?('Bearer ')\n\n    authorization[7..-1] # Entferne das Pr\xe4fix 'Bearer '\n  end\nend\n"})})]})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},81420:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="api.rb"',children:"require 'grape'\nrequire_relative 'auth_helpers'\nrequire_relative 'auth_constants'\nrequire_relative 'auth_info'\nrequire_relative 'authorization_error'\nrequire_relative 'jwt_validator'\n\nclass API < Grape::API\n  format :json\n\n  helpers GrapeAuthHelpers\n\n  namespace :api do\n    namespace :protected do\n      before do\n        authenticate_user!\n      end\n\n      get do\n        # Zugriff auf Authentifizierungsinformationen aus dem Auth-Helper\n        { auth: auth.to_h }\n      end\n    end\n  end\n\n  # \xd6ffentlicher Endpunkt (nicht gesch\xfctzt)\n  get :public do\n    { message: \"\xd6ffentlicher Endpunkt\" }\n  end\nend\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="config.ru"',children:"require_relative 'api'\n\nrun API\n"})})]})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},77406:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="app/controllers/application_controller.rb"',children:"class ApplicationController < ActionController::API # F\xfcr API-only-Apps\n# class ApplicationController < ActionController::Base # F\xfcr vollst\xe4ndige Rails-Apps\n  include JwtAuthentication\nend\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="app/controllers/api/protected_controller.rb"',children:"class Api::ProtectedController < ApplicationController\n  before_action :verify_access_token\n\n  def index\n    # Zugriff auf Auth-Informationen \xfcber @auth\n    render json: { auth: @auth.to_h }\n  end\nend\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="config/routes.rb"',children:"Rails.application.routes.draw do\n  namespace :api do\n    resources :protected, only: [:index]\n  end\nend\n"})})]})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},51641:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",metastring:'title="app.rb"',children:"require 'sinatra'\nrequire 'json'\nrequire_relative 'auth_middleware'\nrequire_relative 'auth_constants'\nrequire_relative 'auth_info'\nrequire_relative 'authorization_error'\nrequire_relative 'auth_helpers'\nrequire_relative 'jwt_validator'\n\n# Middleware anwenden\nuse AuthMiddleware\n\nget '/api/protected' do\n  content_type :json\n\n  # Authentifizierungsinformationen aus env abrufen\n  auth = env['auth']\n  { auth: auth.to_h }.to_json\nend\n\n# \xd6ffentlicher Endpunkt (nicht durch Middleware gesch\xfctzt)\nget '/' do\n  content_type :json\n  { message: \"\xd6ffentlicher Endpunkt\" }.to_json\nend\n"})})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},40930:(e,n,t)=>{t.d(n,{Ay:()=>g,RM:()=>p});var r=t(25105),i=t(79621),s=t(33435),a=t(38552),o=t(22002);function c(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:'title="middleware.rs"',children:"use crate::{AuthInfo, AuthorizationError, extract_bearer_token};\nuse crate::jwt_validator::JwtValidator;\nuse actix_web::{\n    dev::{forward_ready, Service, ServiceRequest, ServiceResponse, Transform},\n    web, Error, HttpMessage, HttpResponse,\n};\nuse futures::future::{ok, Ready};\nuse std::sync::Arc;\n\npub struct JwtMiddleware {\n    validator: Arc<JwtValidator>,\n}\n\nimpl JwtMiddleware {\n    pub fn new(validator: Arc<JwtValidator>) -> Self {\n        Self { validator }\n    }\n}\n\nimpl<S, B> Transform<S, ServiceRequest> for JwtMiddleware\nwhere\n    S: Service<ServiceRequest, Response = ServiceResponse<B>, Error = Error>,\n    S::Future: 'static,\n    B: 'static,\n{\n    type Response = ServiceResponse<B>;\n    type Error = Error;\n    type InitError = ();\n    type Transform = JwtMiddlewareService<S>;\n    type Future = Ready<Result<Self::Transform, Self::InitError>>;\n\n    fn new_transform(&self, service: S) -> Self::Future {\n        ok(JwtMiddlewareService {\n            service,\n            validator: self.validator.clone(),\n        })\n    }\n}\n\npub struct JwtMiddlewareService<S> {\n    service: S,\n    validator: Arc<JwtValidator>,\n}\n\nimpl<S, B> Service<ServiceRequest> for JwtMiddlewareService<S>\nwhere\n    S: Service<ServiceRequest, Response = ServiceResponse<B>, Error = Error>,\n    S::Future: 'static,\n    B: 'static,\n{\n    type Response = ServiceResponse<B>;\n    type Error = Error;\n    type Future = futures::future::LocalBoxFuture<'static, Result<Self::Response, Self::Error>>;\n\n    forward_ready!(service);\n\n    fn call(&self, req: ServiceRequest) -> Self::Future {\n        let validator = self.validator.clone();\n\n        Box::pin(async move {\n            let authorization = req\n                .headers()\n                .get(\"authorization\")\n                .and_then(|h| h.to_str().ok());\n\n            match extract_bearer_token(authorization)\n                .and_then(|token| validator.validate_jwt(token))\n            {\n                Ok(auth_info) => {\n                    // Auth-Informationen in den Request-Extensions f\xfcr generische Nutzung speichern\n                    req.extensions_mut().insert(auth_info);\n                    let fut = self.service.call(req);\n                    fut.await\n                }\n                Err(e) => {\n                    let response = HttpResponse::build(\n                        actix_web::http::StatusCode::from_u16(e.status_code)\n                            .unwrap_or(actix_web::http::StatusCode::FORBIDDEN),\n                    )\n                    .json(serde_json::json!({ \"error\": e.message }));\n\n                    Ok(req.into_response(response))\n                }\n            }\n        })\n    }\n}\n"})})}function u(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:'title="middleware.rs"',children:'use crate::{AuthInfo, AuthorizationError, extract_bearer_token};\nuse crate::jwt_validator::JwtValidator;\nuse axum::{\n    extract::Request,\n    http::{HeaderMap, StatusCode},\n    middleware::Next,\n    response::{IntoResponse, Response},\n    Extension, Json,\n};\nuse serde_json::json;\nuse std::sync::Arc;\n\n// JWT-Middleware zur \xdcberpr\xfcfung und Speicherung von Authentifizierungsinformationen\npub async fn jwt_middleware(\n    Extension(validator): Extension<Arc<JwtValidator>>,\n    headers: HeaderMap,\n    mut request: Request,\n    next: Next,\n) -> Result<Response, AuthorizationError> {\n    let authorization = headers\n        .get("authorization")\n        .and_then(|h| h.to_str().ok());\n\n    let token = extract_bearer_token(authorization)?;\n    let auth_info = validator.validate_jwt(token)?;\n\n    // Authentifizierungsinformationen in den Request-Extensions f\xfcr generische Nutzung speichern\n    request.extensions_mut().insert(auth_info);\n\n    Ok(next.run(request).await)\n}\n\n// Fehlerbehandlung f\xfcr Autorisierungsfehler\nimpl IntoResponse for AuthorizationError {\n    fn into_response(self) -> Response {\n        let status = StatusCode::from_u16(self.status_code).unwrap_or(StatusCode::FORBIDDEN);\n        (status, Json(json!({ "error": self.message }))).into_response()\n    }\n}\n'})})}function d(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:'title="guards.rs"',children:"use crate::{AuthInfo, AuthorizationError, extract_bearer_token};\nuse crate::jwt_validator::JwtValidator;\nuse rocket::{\n    http::Status,\n    outcome::Outcome,\n    request::{self, FromRequest, Request},\n    State,\n};\n\n#[rocket::async_trait]\nimpl<'r> FromRequest<'r> for AuthInfo {\n    type Error = AuthorizationError;\n\n    async fn from_request(req: &'r Request<'_>) -> request::Outcome<Self, Self::Error> {\n        let validator = match req.guard::<&State<JwtValidator>>().await {\n            Outcome::Success(validator) => validator,\n            Outcome::Failure((status, _)) => {\n                return Outcome::Failure((\n                    status,\n                    AuthorizationError::with_status(\"JWT validator not found\", 500),\n                ))\n            }\n            Outcome::Forward(()) => {\n                return Outcome::Forward(())\n            }\n        };\n\n        let authorization = req.headers().get_one(\"authorization\");\n\n        match extract_bearer_token(authorization)\n            .and_then(|token| validator.validate_jwt(token))\n        {\n            Ok(auth_info) => Outcome::Success(auth_info),\n            Err(e) => {\n                let status = Status::from_code(e.status_code).unwrap_or(Status::Forbidden);\n                Outcome::Failure((status, e))\n            }\n        }\n    }\n}\n"})})}const l=Object.freeze({axum:(0,r.jsx)((function(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}),{}),"actix-web":(0,r.jsx)((function(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}),{}),rocket:(0,r.jsx)((function(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}),{})}),p=[];function h(e){const n={a:"a",code:"code",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Wir verwenden ",(0,r.jsx)(n.a,{href:"https://github.com/Keats/jsonwebtoken",children:"jsonwebtoken"}),", um JWTs zu validieren. F\xfcge die ben\xf6tigten Abh\xe4ngigkeiten zu deiner ",(0,r.jsx)(n.code,{children:"Cargo.toml"})," hinzu:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-toml",metastring:'title="Cargo.toml"',children:'[dependencies]\njsonwebtoken = "9.0"\nserde = { version = "1.0", features = ["derive"] }\nserde_json = "1.0"\nreqwest = { version = "0.11", features = ["json"] }\ntokio = { version = "1.0", features = ["full"] }\n'})}),"\n",(0,r.jsx)(n.p,{children:"F\xfcge zun\xe4chst diese gemeinsamen Hilfsfunktionen hinzu, um die JWT-Validierung zu behandeln:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:'title="jwt_validator.rs"',children:'use crate::{AuthInfo, AuthorizationError, ISSUER, JWKS_URI};\nuse jsonwebtoken::{decode, decode_header, Algorithm, DecodingKey, Validation};\nuse serde_json::Value;\nuse std::collections::HashMap;\n\npub struct JwtValidator {\n    jwks: HashMap<String, DecodingKey>,\n}\n\nimpl JwtValidator {\n    pub async fn new() -> Result<Self, AuthorizationError> {\n        let jwks = Self::fetch_jwks().await?;\n        Ok(Self { jwks })\n    }\n\n    async fn fetch_jwks() -> Result<HashMap<String, DecodingKey>, AuthorizationError> {\n        let response = reqwest::get(JWKS_URI).await.map_err(|e| {\n            AuthorizationError::with_status(format!("Failed to fetch JWKS: {}", e), 401)\n        })?;\n\n        let jwks: Value = response.json().await.map_err(|e| {\n            AuthorizationError::with_status(format!("Failed to parse JWKS: {}", e), 401)\n        })?;\n\n        let mut keys = HashMap::new();\n\n        if let Some(keys_array) = jwks["keys"].as_array() {\n            for key in keys_array {\n                if let (Some(kid), Some(kty), Some(n), Some(e)) = (\n                    key["kid"].as_str(),\n                    key["kty"].as_str(),\n                    key["n"].as_str(),\n                    key["e"].as_str(),\n                ) {\n                    if kty == "RSA" {\n                        if let Ok(decoding_key) = DecodingKey::from_rsa_components(n, e) {\n                            keys.insert(kid.to_string(), decoding_key);\n                        }\n                    }\n                }\n            }\n        }\n\n        if keys.is_empty() {\n            return Err(AuthorizationError::with_status("No valid keys found in JWKS", 401));\n        }\n\n        Ok(keys)\n    }\n\n    pub fn validate_jwt(&self, token: &str) -> Result<AuthInfo, AuthorizationError> {\n        let header = decode_header(token).map_err(|e| {\n            AuthorizationError::with_status(format!("Invalid token header: {}", e), 401)\n        })?;\n\n        let kid = header.kid.ok_or_else(|| {\n            AuthorizationError::with_status("Token missing kid claim", 401)\n        })?;\n\n        let key = self.jwks.get(&kid).ok_or_else(|| {\n            AuthorizationError::with_status("Unknown key ID", 401)\n        })?;\n\n        let mut validation = Validation::new(Algorithm::RS256);\n        validation.set_issuer(&[ISSUER]);\n        validation.validate_aud = false; // Wir \xfcberpr\xfcfen die Zielgruppe manuell\n\n        let token_data = decode::<Value>(token, key, &validation).map_err(|e| {\n            AuthorizationError::with_status(format!("Invalid token: {}", e), 401)\n        })?;\n\n        let claims = token_data.claims;\n        self.verify_payload(&claims)?;\n\n        Ok(self.create_auth_info(claims))\n    }\n\n    fn verify_payload(&self, claims: &Value) -> Result<(), AuthorizationError> {\n        // Implementiere hier deine Verifizierungslogik basierend auf dem Berechtigungsmodell\n        // Dies wird im Abschnitt zu den Berechtigungsmodellen unten gezeigt\n        Ok(())\n    }\n\n    fn create_auth_info(&self, claims: Value) -> AuthInfo {\n        let scopes = claims["scope"]\n            .as_str()\n            .map(|s| s.split(\' \').map(|s| s.to_string()).collect())\n            .unwrap_or_default();\n\n        let audience = match &claims["aud"] {\n            Value::Array(arr) => arr.iter().filter_map(|v| v.as_str().map(|s| s.to_string())).collect(),\n            Value::String(s) => vec![s.clone()],\n            _ => vec![],\n        };\n\n        AuthInfo::new(\n            claims["sub"].as_str().unwrap_or_default().to_string(),\n            claims["client_id"].as_str().map(|s| s.to_string()),\n            claims["organization_id"].as_str().map(|s| s.to_string()),\n            scopes,\n            audience,\n        )\n    }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Implementiere anschlie\xdfend das Middleware, um das Zugangstoken zu \xfcberpr\xfcfen:"}),"\n",e.framework?l[e.framework]:(0,r.jsx)(o.A,{groupId:"api-framework",children:Object.entries(l).map((([e,n])=>(0,r.jsx)(a.A,{value:e,label:(0,s.My)(e),children:n},e)))}),"\n",(0,r.jsxs)(n.p,{children:["Entsprechend deinem Berechtigungsmodell implementiere die passende Verifizierungslogik in ",(0,r.jsx)(n.code,{children:"JwtValidator"}),":"]}),"\n",(0,r.jsxs)(o.A,{groupId:"permission-models",children:[(0,r.jsx)(a.A,{value:"global-api-resources",label:"Globale API-Ressourcen",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:'title="jwt_validator.rs"',children:'fn verify_payload(&self, claims: &Value) -> Result<(), AuthorizationError> {\n    // \xdcberpr\xfcfe, ob der Audience-Claim mit deinem API-Ressourcenindikator \xfcbereinstimmt\n    let audiences = match &claims["aud"] {\n        Value::Array(arr) => arr.iter().filter_map(|v| v.as_str()).collect::<Vec<_>>(),\n        Value::String(s) => vec![s.as_str()],\n        _ => vec![],\n    };\n\n    if !audiences.contains(&"https://your-api-resource-indicator") {\n        return Err(AuthorizationError::new("Invalid audience"));\n    }\n\n    // \xdcberpr\xfcfe erforderliche Berechtigungen f\xfcr globale API-Ressourcen\n    let required_scopes = vec!["api:read", "api:write"]; // Ersetze durch deine tats\xe4chlich ben\xf6tigten Berechtigungen\n    let scopes = claims["scope"]\n        .as_str()\n        .map(|s| s.split(\' \').collect::<Vec<_>>())\n        .unwrap_or_default();\n\n    for required_scope in &required_scopes {\n        if !scopes.contains(required_scope) {\n            return Err(AuthorizationError::new("Insufficient scope"));\n        }\n    }\n\n    Ok(())\n}\n'})})}),(0,r.jsx)(a.A,{value:"organization-permissions",label:"Organisation (nicht-API) Berechtigungen",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:'title="jwt_validator.rs"',children:'fn verify_payload(&self, claims: &Value) -> Result<(), AuthorizationError> {\n    // \xdcberpr\xfcfe, ob der Audience-Claim dem Organisationsformat entspricht\n    let audiences = match &claims["aud"] {\n        Value::Array(arr) => arr.iter().filter_map(|v| v.as_str()).collect::<Vec<_>>(),\n        Value::String(s) => vec![s.as_str()],\n        _ => vec![],\n    };\n\n    let has_org_audience = audiences.iter().any(|aud| aud.starts_with("urn:logto:organization:"));\n    if !has_org_audience {\n        return Err(AuthorizationError::new("Invalid audience for organization permissions"));\n    }\n\n    // \xdcberpr\xfcfe, ob die Organisations-ID mit dem Kontext \xfcbereinstimmt (du musst dies ggf. aus dem Request-Kontext extrahieren)\n    let expected_org_id = "your-organization-id"; // Aus dem Request-Kontext extrahieren\n    let expected_aud = format!("urn:logto:organization:{}", expected_org_id);\n    if !audiences.contains(&expected_aud.as_str()) {\n        return Err(AuthorizationError::new("Organization ID mismatch"));\n    }\n\n    // \xdcberpr\xfcfe erforderliche Organisationsberechtigungen\n    let required_scopes = vec!["invite:users", "manage:settings"]; // Ersetze durch deine tats\xe4chlich ben\xf6tigten Berechtigungen\n    let scopes = claims["scope"]\n        .as_str()\n        .map(|s| s.split(\' \').collect::<Vec<_>>())\n        .unwrap_or_default();\n\n    for required_scope in &required_scopes {\n        if !scopes.contains(required_scope) {\n            return Err(AuthorizationError::new("Insufficient organization scope"));\n        }\n    }\n\n    Ok(())\n}\n'})})}),(0,r.jsx)(a.A,{value:"organization-level-api-resources",label:"Organisationsbezogene API-Ressourcen",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:'title="jwt_validator.rs"',children:'fn verify_payload(&self, claims: &Value) -> Result<(), AuthorizationError> {\n    // \xdcberpr\xfcfe, ob der Audience-Claim mit deinem API-Ressourcenindikator \xfcbereinstimmt\n    let audiences = match &claims["aud"] {\n        Value::Array(arr) => arr.iter().filter_map(|v| v.as_str()).collect::<Vec<_>>(),\n        Value::String(s) => vec![s.as_str()],\n        _ => vec![],\n    };\n\n    if !audiences.contains(&"https://your-api-resource-indicator") {\n        return Err(AuthorizationError::new("Invalid audience for organization-level API resources"));\n    }\n\n    // \xdcberpr\xfcfe, ob die Organisations-ID mit dem Kontext \xfcbereinstimmt (du musst dies ggf. aus dem Request-Kontext extrahieren)\n    let expected_org_id = "your-organization-id"; // Aus dem Request-Kontext extrahieren\n    let org_id = claims["organization_id"].as_str().unwrap_or_default();\n    if expected_org_id != org_id {\n        return Err(AuthorizationError::new("Organization ID mismatch"));\n    }\n\n    // \xdcberpr\xfcfe erforderliche Berechtigungen f\xfcr organisationsbezogene API-Ressourcen\n    let required_scopes = vec!["api:read", "api:write"]; // Ersetze durch deine tats\xe4chlich ben\xf6tigten Berechtigungen\n    let scopes = claims["scope"]\n        .as_str()\n        .map(|s| s.split(\' \').collect::<Vec<_>>())\n        .unwrap_or_default();\n\n    for required_scope in &required_scopes {\n        if !scopes.contains(required_scope) {\n            return Err(AuthorizationError::new("Insufficient organization-level API scopes"));\n        }\n    }\n\n    Ok(())\n}\n'})})})]})]})}function g(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},93867:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:'title="lib.rs"',children:'use serde::{Deserialize, Serialize};\nuse std::fmt;\n\npub const JWKS_URI: &str = "https://your-tenant.logto.app/oidc/jwks";\npub const ISSUER: &str = "https://your-tenant.logto.app/oidc";\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AuthInfo {\n    pub sub: String,\n    pub client_id: Option<String>,\n    pub organization_id: Option<String>,\n    pub scopes: Vec<String>,\n    pub audience: Vec<String>,\n}\n\nimpl AuthInfo {\n    pub fn new(\n        sub: String,\n        client_id: Option<String>,\n        organization_id: Option<String>,\n        scopes: Vec<String>,\n        audience: Vec<String>,\n    ) -> Self {\n        Self {\n            sub,\n            client_id,\n            organization_id,\n            scopes,\n            audience,\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct AuthorizationError {\n    pub message: String,\n    pub status_code: u16,\n}\n\nimpl AuthorizationError {\n    pub fn new(message: impl Into<String>) -> Self {\n        Self {\n            message: message.into(),\n            status_code: 403,\n        }\n    }\n\n    pub fn with_status(message: impl Into<String>, status_code: u16) -> Self {\n        Self {\n            message: message.into(),\n            status_code,\n        }\n    }\n}\n\nimpl fmt::Display for AuthorizationError {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        write!(f, "{}", self.message)\n    }\n}\n\nimpl std::error::Error for AuthorizationError {}\n\npub fn extract_bearer_token(authorization: Option<&str>) -> Result<&str, AuthorizationError> {\n    let auth_header = authorization.ok_or_else(|| {\n        AuthorizationError::with_status("Authorization-Header fehlt", 401)\n    })?;\n\n    if !auth_header.starts_with("Bearer ") {\n        return Err(AuthorizationError::with_status(\n            "Authorization-Header muss mit \\"Bearer \\" beginnen",\n            401,\n        ));\n    }\n\n    Ok(&auth_header[7..]) // Entferne das Pr\xe4fix \'Bearer \'\n}\n'})})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},65487:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:'title="main.rs"',children:'use actix_web::{middleware::Logger, web, App, HttpRequest, HttpServer, Result};\nuse serde_json::{json, Value};\nuse std::sync::Arc;\n\nmod lib;\nmod jwt_validator;\nmod middleware as jwt_middleware;\n\nuse lib::AuthInfo;\nuse jwt_validator::JwtValidator;\nuse jwt_middleware::JwtMiddleware;\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    let validator = Arc::new(JwtValidator::new().await.expect("Fehler beim Initialisieren des JWT-Validators"));\n\n    HttpServer::new(move || {\n        App::new()\n            .app_data(web::Data::new(validator.clone()))\n            .wrap(Logger::default())\n            .service(\n                web::scope("/api/protected")\n                    .wrap(JwtMiddleware::new(validator.clone()))\n                    .route("", web::get().to(protected_handler))\n            )\n    })\n    .bind("127.0.0.1:8080")?\n    .run()\n    .await\n}\n\nasync fn protected_handler(req: HttpRequest) -> Result<web::Json<Value>> {\n    // Zugriff auf Authentifizierungsinformationen aus den Erweiterungen der Anfrage\n    let auth = req.extensions().get::<AuthInfo>().unwrap();\n    Ok(web::Json(json!({ "auth": auth })))\n}\n'})})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},3692:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:'title="main.rs"',children:'use axum::{\n    extract::Extension,\n    http::StatusCode,\n    middleware,\n    response::Json,\n    routing::get,\n    Router,\n};\nuse serde_json::{json, Value};\nuse std::sync::Arc;\nuse tower_http::cors::CorsLayer;\n\nmod lib;\nmod jwt_validator;\nmod middleware as jwt_middleware;\n\nuse lib::AuthInfo;\nuse jwt_validator::JwtValidator;\n\n#[tokio::main]\nasync fn main() {\n    let validator = Arc::new(JwtValidator::new().await.expect("Initialisierung des JWT-Validators fehlgeschlagen"));\n\n    let app = Router::new()\n        .route("/api/protected", get(protected_handler))\n        .layer(middleware::from_fn(jwt_middleware::jwt_middleware))\n        .layer(Extension(validator))\n        .layer(CorsLayer::permissive());\n\n    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await.unwrap();\n    axum::serve(listener, app).await.unwrap();\n}\n\nasync fn protected_handler(Extension(auth): Extension<AuthInfo>) -> Json<Value> {\n    // Greife direkt \xfcber Extension auf Auth-Informationen zu\n    Json(json!({ "auth": auth }))\n}\n'})})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},39427:(e,n,t)=>{t.d(n,{Ay:()=>o,RM:()=>s});var r=t(25105),i=t(79621);const s=[];function a(e){const n={code:"code",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:'title="main.rs"',children:'use rocket::{get, launch, routes, serde::json::Json};\nuse serde_json::{json, Value};\n\nmod lib;\nmod jwt_validator;\nmod guards;\n\nuse lib::AuthInfo;\nuse jwt_validator::JwtValidator;\n\n#[get("/api/protected")]\nfn protected_handler(auth: AuthInfo) -> Json<Value> {\n    // Greife direkt \xfcber den Request Guard auf Authentifizierungsinformationen zu\n    Json(json!({ "auth": auth }))\n}\n\n#[launch]\nasync fn rocket() -> _ {\n    let validator = JwtValidator::new().await.expect("Initialisierung des JWT-Validators fehlgeschlagen");\n\n    rocket::build()\n        .manage(validator)\n        .mount("/", routes![protected_handler])\n}\n'})})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},38552:(e,n,t)=>{t.d(n,{A:()=>a});t(58101);var r=t(13526);const i={tabItem:"tabItem_dgSZ"};var s=t(25105);function a(e){let{children:n,hidden:t,className:a}=e;return(0,s.jsx)("div",{role:"tabpanel",className:(0,r.A)(i.tabItem,a),hidden:t,children:n})}},22002:(e,n,t)=>{t.d(n,{A:()=>y});var r=t(58101),i=t(13526),s=t(60755),a=t(55234),o=t(6635),c=t(4100),u=t(35661),d=t(42752);function l(e){return r.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:n,children:t}=e;return(0,r.useMemo)((()=>{const e=n??function(e){return l(e).map((e=>{let{props:{value:n,label:t,attributes:r,default:i}}=e;return{value:n,label:t,attributes:r,default:i}}))}(t);return function(e){const n=(0,u.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function h(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function g(e){let{queryString:n=!1,groupId:t}=e;const i=(0,a.W6)(),s=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,c.aZ)(s),(0,r.useCallback)((e=>{if(!s)return;const n=new URLSearchParams(i.location.search);n.set(s,e),i.replace({...i.location,search:n.toString()})}),[s,i])]}function m(e){const{defaultValue:n,queryString:t=!1,groupId:i}=e,s=p(e),[a,c]=(0,r.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!h({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const r=t.find((e=>e.default))??t[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:s}))),[u,l]=g({queryString:t,groupId:i}),[m,f]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[i,s]=(0,d.Dv)(t);return[i,(0,r.useCallback)((e=>{t&&s.set(e)}),[t,s])]}({groupId:i}),x=(()=>{const e=u??m;return h({value:e,tabValues:s})?e:null})();(0,o.A)((()=>{x&&c(x)}),[x]);return{selectedValue:a,selectValue:(0,r.useCallback)((e=>{if(!h({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);c(e),l(e),f(e)}),[l,f,s]),tabValues:s}}var f=t(21929);const x={tabList:"tabList_osvQ",tabItem:"tabItem_dc4O"};var j=t(25105);function A(e){let{className:n,block:t,selectedValue:r,selectValue:a,tabValues:o}=e;const c=[],{blockElementScrollPositionUntilNextRender:u}=(0,s.a_)(),d=e=>{const n=e.currentTarget,t=c.indexOf(n),i=o[t].value;i!==r&&(u(n),a(i))},l=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const t=c.indexOf(e.currentTarget)+1;n=c[t]??c[0];break}case"ArrowLeft":{const t=c.indexOf(e.currentTarget)-1;n=c[t]??c[c.length-1];break}}n?.focus()};return(0,j.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":t},n),children:o.map((e=>{let{value:n,label:t,attributes:s}=e;return(0,j.jsx)("li",{role:"tab",tabIndex:r===n?0:-1,"aria-selected":r===n,ref:e=>{c.push(e)},onKeyDown:l,onClick:d,...s,className:(0,i.A)("tabs__item",x.tabItem,s?.className,{"tabs__item--active":r===n}),children:t??n},n)}))})}function w(e){let{lazy:n,children:t,selectedValue:s}=e;const a=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=a.find((e=>e.props.value===s));return e?(0,r.cloneElement)(e,{className:(0,i.A)("margin-top--md",e.props.className)}):null}return(0,j.jsx)("div",{className:"margin-top--md",children:a.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==s})))})}function b(e){const n=m(e);return(0,j.jsxs)("div",{className:(0,i.A)("tabs-container",x.tabList),children:[(0,j.jsx)(A,{...n,...e}),(0,j.jsx)(w,{...n,...e})]})}function y(e){const n=(0,f.A)();return(0,j.jsx)(b,{...e,children:l(e.children)},String(n))}},33435:(e,n,t)=>{t.d(n,{Id:()=>a,My:()=>s});const r=Object.freeze({dotnet:{name:".NET"},go:{name:"Go"},java:{name:"Java"},nodejs:{name:"Node.js"},php:{name:"PHP"},python:{name:"Python"},ruby:{name:"Ruby"},rust:{name:"Rust"}}),i=Object.freeze({express:{name:"Express.js",language:"nodejs"},koa:{name:"Koa.js",language:"nodejs"},fastify:{name:"Fastify",language:"nodejs"},hapi:{name:"Hapi.js",language:"nodejs"},nestjs:{name:"NestJS",language:"nodejs"},gin:{name:"Gin",language:"go"},fiber:{name:"Fiber",language:"go"},echo:{name:"Echo",language:"go"},chi:{name:"Chi",language:"go"},"spring-boot":{name:"Spring Boot",language:"java"},quarkus:{name:"Quarkus",language:"java"},micronaut:{name:"Micronaut",language:"java"},"vertx-web":{name:"Vert.x Web",language:"java"},laravel:{name:"Laravel",language:"php"},symfony:{name:"Symfony",language:"php"},slim:{name:"Slim",language:"php"},rails:{name:"Ruby on Rails",language:"ruby"},sinatra:{name:"Sinatra",language:"ruby"},grape:{name:"Grape",language:"ruby"},fastapi:{name:"FastAPI",language:"python"},flask:{name:"Flask",language:"python"},django:{name:"Django",language:"python"},"django-rest":{name:"Django REST Framework",language:"python"},axum:{name:"Axum",language:"rust"},"actix-web":{name:"Actix Web",language:"rust"},rocket:{name:"Rocket",language:"rust"},"aspnet-core":{name:"ASP.NET Core",language:"dotnet"}}),s=e=>i[e].name,a=e=>r[i[e].language].name},79621:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(58101);const i={},s=r.createContext(i);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);