"use strict";(self.webpackChunk_logto_docs=self.webpackChunk_logto_docs||[]).push([[3954],{73286:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>u,contentTitle:()=>d,default:()=>c,frontMatter:()=>a,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"quick-starts/database/supabase/README","title":"Authentifizierung zu deiner Supabase-Anwendung hinzuf\xfcgen (Add authentication to your Supabase application)","description":"Supabase-Grundlagen \\\\","source":"@site/i18n/de/docusaurus-plugin-content-docs/current/quick-starts/database/supabase/README.mdx","sourceDirName":"quick-starts/database/supabase","slug":"/quick-starts/supabase","permalink":"/de/quick-starts/supabase","draft":false,"unlisted":false,"editUrl":"https://github.com/logto-io/docs/tree/master/i18n/de/docusaurus-plugin-content-docs/current/quick-starts/database/supabase/README.mdx","tags":[],"version":"current","frontMatter":{"slug":"/quick-starts/supabase","sidebar_label":"Supabase","sidebar_custom_props":{"description":"Logto in Supabase integrieren.","logoFilename":"supabase.svg"}},"sidebar":"quickStartSidebar","previous":{"title":"Hasura","permalink":"/de/quick-starts/hasura"},"next":{"title":"OIDC (Drittanbieter-App)","permalink":"/de/quick-starts/third-party-oidc"}}');var i=s(25105),r=s(79621);const a={slug:"/quick-starts/supabase",sidebar_label:"Supabase",sidebar_custom_props:{description:"Logto in Supabase integrieren.",logoFilename:"supabase.svg"}},d="Authentifizierung zu deiner Supabase-Anwendung hinzuf\xfcgen (Add authentication to your Supabase application)",u={},o=[{value:"Supabase-Grundlagen",id:"supabase-basics",level:2},{value:"Benutzerdaten zu den Supabase-Anfragen hinzuf\xfcgen",id:"add-user-data-to-the-supabase-requests",level:3},{value:"Row-Level-Security-Policy erstellen",id:"create-row-level-security-policy",level:3},{value:"Grundlegender Integrationsprozess mit Logto",id:"basic-integration-process-with-logto",level:3},{value:"Logto-Integration",id:"logto-integration",level:2},{value:"Native App oder SPA",id:"native-app-or-spa",level:3},{value:"Traditionelle Web-App",id:"traditional-web-app",level:3},{value:"Maschine-zu-Maschine-App",id:"machine-to-machine-app",level:3}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"authentifizierung-zu-deiner-supabase-anwendung-hinzuf\xfcgen-add-authentication-to-your-supabase-application",children:"Authentifizierung zu deiner Supabase-Anwendung hinzuf\xfcgen (Add authentication to your Supabase application)"})}),"\n",(0,i.jsx)(n.h2,{id:"supabase-basics",children:"Supabase-Grundlagen"}),"\n",(0,i.jsxs)(n.p,{children:["Supabase nutzt ",(0,i.jsx)(n.a,{href:"https://www.postgresql.org/docs/current/ddl-rowsecurity.html",children:"Postgres' Row-Level Security"}),", um Datenzugriffsberechtigungen zu steuern. Einfach gesagt: Durch das Erstellen von Row-Level-Security-Policies f\xfcr Tabellen in der Datenbank k\xf6nnen wir einschr\xe4nken und verwalten, wer Daten in einer Tabelle lesen, schreiben und aktualisieren darf."]}),"\n",(0,i.jsx)(n.p,{children:'Angenommen, du hast eine Tabelle namens "posts" in deiner Datenbank mit folgendem Inhalt:'}),"\n",(0,i.jsx)("img",{src:"/img/assets/posts-table.webp",alt:"Posts-Tabelle"}),"\n",(0,i.jsxs)(n.p,{children:["Das Feld ",(0,i.jsx)(n.code,{children:"user_id"})," in der Tabelle repr\xe4sentiert den Benutzer, dem die jeweiligen Post-Daten geh\xf6ren. Du kannst jeden Benutzer darauf beschr\xe4nken, nur auf seine eigenen Post-Daten basierend auf dem Feld ",(0,i.jsx)(n.code,{children:"user_id"})," zuzugreifen."]}),"\n",(0,i.jsx)(n.p,{children:"Bevor dies jedoch umgesetzt werden kann, muss Supabase in der Lage sein, den aktuellen Benutzer zu identifizieren, der auf die Datenbank zugreift."}),"\n",(0,i.jsx)(n.h3,{id:"add-user-data-to-the-supabase-requests",children:"Benutzerdaten zu den Supabase-Anfragen hinzuf\xfcgen"}),"\n",(0,i.jsx)(n.p,{children:"Dank der Unterst\xfctzung von JWT durch Supabase k\xf6nnen wir beim Interagieren unserer Anwendung mit Supabase ein JWT generieren, das Benutzerdaten enth\xe4lt, und zwar mit dem von Supabase bereitgestellten JWT-Secret. Dieses JWT verwenden wir dann als Authentication-Header bei Anfragen. Nach Erhalt der Anfrage pr\xfcft Supabase automatisch die G\xfcltigkeit des JWT und erm\xf6glicht den Zugriff auf die darin enthaltenen Daten w\xe4hrend der weiteren Verarbeitung."}),"\n",(0,i.jsx)(n.p,{children:"Zun\xe4chst k\xf6nnen wir das von Supabase bereitgestellte JWT-Secret in den \u201eProject Settings\u201c im Supabase-Dashboard abrufen:"}),"\n",(0,i.jsx)("img",{src:"/img/assets/supabase-api-settings.webp",alt:"Supabase API-Einstellungsseite"}),"\n",(0,i.jsx)(n.p,{children:"Wenn wir dann das Supabase SDK verwenden, um Anfragen an Supabase zu stellen, nutzen wir dieses Secret, um unser JWT zu generieren und es als Authentication-Header an die Anfrage anzuh\xe4ngen. (Beachte, dass dieser Vorgang im Backend-Service deiner Anwendung stattfindet und das JWT-Secret niemals Dritten zug\xe4nglich gemacht werden sollte)."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"import { createClient } from '@supabase/supabase-js';\nimport { sign } from 'jsonwebtoken';\n\n/\n * Hinweis:\n * Du findest SUPABASE_URL und SUPABASE_ANON_KEY an derselben Stelle wie das JWT-Secret.\n */\nconst SUPABASE_URL = process.env.SUPABASE_URL;\nconst SUPABASE_ANON_KEY = process.env.SUPABASE_ANON_KEY;\n\nconst SUPABASE_JWT_SECRET = process.env.SUPABASE_JWT_SECRET;\n\nexport const getSupabaseClient = (userId) => {\n  const jwtPayload = {\n    userId,\n  };\n\n  const jwt = sign(jwtPayload, SUPABASE_JWT_SECRET, {\n    expiresIn: '1h', // Nur zu Demonstrationszwecken\n  });\n\n  const client = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {\n    global: {\n      headers: {\n        Authorization: `Bearer ${jwt}`,\n      },\n    },\n  });\n\n  return client;\n};\n"})}),"\n",(0,i.jsx)(n.p,{children:"Navigiere anschlie\xdfend zum SQL-Editor im Supabase-Dashboard und erstelle eine Funktion, um die userId aus der Anfrage auszulesen:"}),"\n",(0,i.jsx)("img",{src:"/img/assets/create-get-user-id-function.webp",alt:"Funktion zum Abrufen der Benutzer-ID erstellen"}),"\n",(0,i.jsx)(n.p,{children:"Der im Bild verwendete Code lautet wie folgt:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"create or replace function auth.user_id() returns text as $$\n  select nullif(current_setting('request.jwt.claims', true)::json->>'userId', '')::text;\n$$ language sql stable;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Wie der Code zeigt, kannst du in Supabase das Payload des von uns generierten JWT abrufen, indem du ",(0,i.jsx)(n.code,{children:"request.jwt.claims"})," aufrufst. Das Feld ",(0,i.jsx)(n.code,{children:"userId"})," im Payload ist der von uns gesetzte Wert."]}),"\n",(0,i.jsx)(n.p,{children:"Mit dieser Funktion kann Supabase den aktuell auf die Datenbank zugreifenden Benutzer bestimmen."}),"\n",(0,i.jsx)(n.h3,{id:"create-row-level-security-policy",children:"Row-Level-Security-Policy erstellen"}),"\n",(0,i.jsxs)(n.p,{children:["Nun k\xf6nnen wir eine Row-Level-Security-Policy erstellen, um jeden Benutzer darauf zu beschr\xe4nken, nur auf seine eigenen Post-Daten basierend auf dem Feld ",(0,i.jsx)(n.code,{children:"user_id"})," in der Tabelle posts zuzugreifen."]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Navigiere zur Table Editor-Seite im Supabase-Dashboard und w\xe4hle die Tabelle posts aus."}),"\n",(0,i.jsx)(n.li,{children:'Klicke oben in der Tabelle auf "Add RLS Policy".'}),"\n",(0,i.jsx)(n.li,{children:'Klicke im angezeigten Fenster auf "Create policy".'}),"\n",(0,i.jsx)(n.li,{children:"Gib einen Policy-Namen ein und w\xe4hle den SELECT-Policy-Befehl."}),"\n",(0,i.jsxs)(n.li,{children:["Gib im ",(0,i.jsx)(n.code,{children:"using"}),"-Block des folgenden Codes ein:"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"auth.user_id() = user_id\n"})}),"\n",(0,i.jsx)("img",{src:"/img/assets/create-rls-policy.webp",alt:"RLS-Policy erstellen"}),"\n",(0,i.jsx)(n.p,{children:"Durch solche Policies wird die Datenzugriffskontrolle in Supabase realisiert."}),"\n",(0,i.jsxs)(n.p,{children:["In realen Anwendungen w\xfcrdest du verschiedene Policies erstellen, um Benutzeraktionen wie das Einf\xfcgen und \xc4ndern von Daten einzuschr\xe4nken. Dies geht jedoch \xfcber den Rahmen dieses Artikels hinaus. Weitere Informationen zu Row-Level Security (RLS) findest du unter ",(0,i.jsx)(n.a,{href:"https://supabase.com/docs/guides/database/postgres/row-level-security",children:"Secure your data using Postgres Row Level Security"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"basic-integration-process-with-logto",children:"Grundlegender Integrationsprozess mit Logto"}),"\n",(0,i.jsx)(n.p,{children:"Wie bereits erw\xe4hnt, nutzt Supabase RLS f\xfcr die Zugriffskontrolle. Der Schl\xfcssel zur Integration mit Logto (oder jedem anderen Authentifizierungsdienst) liegt darin, die Benutzer-ID des autorisierten Benutzers zu erhalten und an Supabase zu \xfcbermitteln. Der gesamte Prozess ist im folgenden Diagramm dargestellt:"}),"\n",(0,i.jsx)(n.mermaid,{value:"sequenceDiagram\n\tTeilnehmer U als Endbenutzer\n\tTeilnehmer Logto\n\tTeilnehmer B als App-Backend-Service\n\tTeilnehmer Supabase\n\n\tU->>Logto: Anmeldung mit Logto\n\tLogto--\x3e>U: `access_token`\n\tU->>B: Datenanfrage mit `access_token`\n\tB->>B: `user_id` aus `access_token` extrahieren\n\tB->>B: JWT generieren mit `user_id` & `Supabase JWT secret`\n\tB->>Supabase: Datenanfrage mit JWT\n\tSupabase--\x3e>B: Antwortdaten\n\tB--\x3e>U: Antwortdaten"}),"\n",(0,i.jsx)(n.p,{children:"Im Folgenden erkl\xe4ren wir, wie du Logto basierend auf diesem Prozessdiagramm mit Supabase integrierst."}),"\n",(0,i.jsx)(n.h2,{id:"logto-integration",children:"Logto-Integration"}),"\n",(0,i.jsx)(n.p,{children:"Logto bietet Integrationsanleitungen f\xfcr verschiedene Frameworks und Programmiersprachen."}),"\n",(0,i.jsxs)(n.p,{children:["Im Allgemeinen fallen mit diesen Frameworks und Sprachen erstellte Apps in Kategorien wie Native Apps, SPA (Single-Page-Apps), traditionelle Web-Apps und M2M (Maschine-zu-Maschine)-Apps. Du kannst die Seite ",(0,i.jsx)(n.a,{href:"/quick-starts",children:"Logto Schnellstart"})," besuchen, um Logto entsprechend deinem Tech-Stack in deine Anwendung zu integrieren. Anschlie\xdfend folge den untenstehenden Anweisungen, um Logto je nach Anwendungstyp in dein Projekt zu integrieren."]}),"\n",(0,i.jsx)(n.h3,{id:"native-app-or-spa",children:"Native App oder SPA"}),"\n",(0,i.jsx)(n.p,{children:"Sowohl Native Apps als auch SPAs laufen auf deinem Ger\xe4t, und die nach der Anmeldung erhaltenen Zugangsdaten (Access Token) werden lokal auf deinem Ger\xe4t gespeichert."}),"\n",(0,i.jsx)(n.p,{children:"Daher musst du bei der Integration deiner App mit Supabase \xfcber deinen Backend-Service mit Supabase interagieren, da du sensible Informationen (wie das Supabase JWT-Secret) nicht auf jedem Benutzerger\xe4t offenlegen darfst."}),"\n",(0,i.jsxs)(n.p,{children:["Angenommen, du baust deine SPA mit React und Express. Du hast Logto erfolgreich in deine Anwendung integriert, indem du der ",(0,i.jsx)(n.a,{href:"/quick-starts/react",children:"Logto React SDK-Anleitung"})," gefolgt bist (du kannst den Code in unserem ",(0,i.jsx)(n.a,{href:"https://github.com/logto-io/js/tree/master/packages/react-sample",children:"React-Beispiel"})," einsehen). Au\xdferdem hast du die Logto Access Token-Validierung auf deinem Backend-Server gem\xe4\xdf der Anleitung ",(0,i.jsx)(n.a,{href:"/authorization/validate-access-tokens",children:"Zugangstokens validieren"})," hinzugef\xfcgt."]}),"\n",(0,i.jsx)(n.p,{children:"Als N\xe4chstes verwendest du das von Logto erhaltene Access Token, um Benutzerdaten von deinem Backend-Server anzufordern:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"import { useLogto } from '@logto/react';\nimport { useState, useEffect } from 'react';\nimport PostList from './PostList';\n\nconst endpoint = '<https://www.mysite.com/api/posts>';\nconst resource = '<https://www.mysite.com/api>';\n\nfunction PostPage() {\n  const { isAuthenticated, getAccessToken } = useLogto();\n  const [posts, setPosts] = useState();\n\n  useEffect(() => {\n    const fetchPosts = async () => {\n      const response = await fetch(endpoint, {\n        headers: {\n          Authorization: `Bearer ${await getAccessToken(resource)}`,\n        },\n      });\n      setPosts(response.json());\n    };\n\n    if (isAuthenticated) {\n      void fetchPosts();\n    }\n  }, [isAuthenticated, getAccessToken]);\n\n  return <PostList posts={posts} />;\n}\n\nexport default PostPage;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Auf deinem Backend-Server hast du bereits die ID des angemeldeten Benutzers aus dem Access Token mit Middleware extrahiert:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"// auth-middleware.ts\nimport { createRemoteJWKSet, jwtVerify } from 'jose';\n\n//...\n\nexport const verifyAuthFromRequest = async (ctx, next) => {\n  // Token extrahieren\n  const token = extractBearerTokenFromHeaders(ctx.request.headers);\n\n  const { payload } = await jwtVerify(\n    token, // Das rohe Bearer Token aus dem Request-Header\n    createRemoteJWKSet(new URL('https://<your-logto-domain>/oidc/jwks')), // JWKS mit jwks_uri vom Logto-Server generieren\n    {\n      // Erwarteter Aussteller des Tokens, sollte vom Logto-Server stammen\n      issuer: 'https://<your-logto-domain>/oidc',\n      // Erwartete Zielgruppe des Tokens, sollte der Ressourcenindikator der aktuellen API sein\n      audience: '<your request listener resource indicator>',\n    }\n  );\n\n  // falls du RBAC verwendest\n  assert(payload.scope.includes('some_scope'));\n\n  // benutzerdefinierte Payload-Logik\n  ctx.auth = {\n    userId: payload.sub,\n  };\n\n  return next();\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Jetzt kannst du die oben beschriebene Funktion ",(0,i.jsx)(n.code,{children:"getSupabaseClient"})," verwenden, um die ",(0,i.jsx)(n.code,{children:"userId"})," an das JWT f\xfcr nachfolgende Anfragen an Supabase anzuh\xe4ngen. Alternativ kannst du eine Middleware erstellen, um f\xfcr Anfragen, die mit Supabase interagieren m\xfcssen, einen Supabase-Client zu erzeugen:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"export const withSupabaseClient = async (ctx, next) => {\n  ctx.supabase = getSupabaseClient(ctx.auth.userId);\n\n  return next();\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Im weiteren Ablauf kannst du dann direkt ",(0,i.jsx)(n.code,{children:"ctx.supabase"})," aufrufen, um mit Supabase zu interagieren:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"const fetchPosts = async (ctx) => {\n  const { data } = await ctx.supabase.from('posts').select('*');\n\n  return data;\n};\n"})}),"\n",(0,i.jsx)(n.p,{children:"In diesem Code gibt Supabase basierend auf den zuvor festgelegten Policies nur die Post-Daten des aktuellen Benutzers zur\xfcck."}),"\n",(0,i.jsx)(n.h3,{id:"traditional-web-app",children:"Traditionelle Web-App"}),"\n",(0,i.jsx)(n.p,{children:"Der Hauptunterschied zwischen einer traditionellen Web-App und einer Native App oder SPA besteht darin, dass eine traditionelle Web-App Seiten ausschlie\xdflich auf dem Webserver rendert und aktualisiert. Daher werden Benutzeranmeldeinformationen direkt vom Webserver verwaltet, w\xe4hrend sie bei Native Apps und SPAs auf dem Ger\xe4t des Benutzers liegen."}),"\n",(0,i.jsx)(n.p,{children:"Bei der Integration von Logto mit einer traditionellen Web-App in Supabase kannst du die ID des angemeldeten Benutzers direkt im Backend abrufen."}),"\n",(0,i.jsxs)(n.p,{children:["Am Beispiel eines Next.js-Projekts: Nachdem du Logto gem\xe4\xdf der ",(0,i.jsx)(n.a,{href:"/quick-starts/next-app-router",children:"Next.js SDK-Anleitung"})," integriert hast, kannst du mit dem Logto SDK Benutzerinformationen abrufen und das entsprechende JWT f\xfcr die Interaktion mit Supabase erzeugen."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"import { getLogtoContext } from '@logto/next-server-actions';\nimport { logtoConfig } from '@/logto';\nimport { getSupabaseClient } from '@/utils';\nimport PostList from './PostList';\n\nexport default async function PostPage() {\n  const { cliams } = await getLogtoContext(logtoConfig);\n\n  // Der Wert `sub` in `cliams` ist die Benutzer-ID.\n  const supabase = getSupabaseClient(cliams.sub);\n\n  const { data: posts } = await supabase.from('posts').select('*');\n\n  return <PostList posts={posts} />;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"machine-to-machine-app",children:"Maschine-zu-Maschine-App"}),"\n",(0,i.jsx)(n.p,{children:"Maschine-zu-Maschine (M2M) wird h\xe4ufig verwendet, wenn deine App direkt mit Ressourcenservern kommunizieren muss, z. B. ein statischer Dienst, der t\xe4glich Beitr\xe4ge abruft usw."}),"\n",(0,i.jsxs)(n.p,{children:["Du kannst die Anleitung ",(0,i.jsx)(n.a,{href:"/quick-starts/m2m",children:"Maschine-zu-Maschine: Authentifizierung mit Logto"}),' f\xfcr die Authentifizierung von Maschine-zu-Maschine-Apps verwenden. Die Integration zwischen Supabase und Maschine-zu-Maschine-Apps ist \xe4hnlich wie bei Native Apps und SPAs (siehe Abschnitt "',(0,i.jsx)(n.a,{href:"#native-app-or-spa",children:"Native App oder SPA"}),'"). Dabei wird ein Zugangstoken von Logto abgerufen und dann \xfcber eine gesch\xfctzte Backend-API validiert.']}),"\n",(0,i.jsxs)(n.p,{children:["Beachte jedoch, dass Native Apps und SPAs in der Regel f\xfcr Endbenutzer konzipiert sind, sodass die erhaltene Benutzer-ID den Benutzer selbst repr\xe4sentiert. Das Zugangstoken f\xfcr Maschine-zu-Maschine-Apps hingegen repr\xe4sentiert die Anwendung selbst, und das Feld ",(0,i.jsx)(n.code,{children:"sub"})," im Access Token Payload ist die Client-ID der M2M-App, nicht eines bestimmten Benutzers. Daher ist es w\xe4hrend der Entwicklung wichtig zu unterscheiden, f\xfcr welche Daten M2M-Apps vorgesehen sind."]}),"\n",(0,i.jsxs)(n.p,{children:["Wenn du m\xf6chtest, dass eine bestimmte M2M-App im Namen des gesamten Dienstes auf Supabase zugreift, um RLS-Beschr\xe4nkungen zu umgehen, kannst du das ",(0,i.jsx)(n.code,{children:"service_role"}),"-Secret von Supabase verwenden, um einen Supabase-Client zu erstellen. Das ist n\xfctzlich, wenn du administrative oder automatisierte Aufgaben durchf\xfchren m\xf6chtest, die Zugriff auf alle Daten erfordern, ohne durch die f\xfcr einzelne Benutzer eingerichteten Row-Level-Security-Policies eingeschr\xe4nkt zu sein."]}),"\n",(0,i.jsxs)(n.p,{children:["Das ",(0,i.jsx)(n.code,{children:"service_role"}),"-Secret findest du auf derselben Seite wie das JWT-Secret:"]}),"\n",(0,i.jsx)("img",{src:"/img/assets/service-role-secret.webp",alt:"Service-Role-Secret"}),"\n",(0,i.jsxs)(n.p,{children:["Beim Erstellen eines Supabase-Clients verwendest du das ",(0,i.jsx)(n.code,{children:"service_role"}),"-Secret, sodass dieser Client auf alle Daten in der Datenbank zugreifen kann:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"import { createClient } from '@supabase/supabase-js';\n\n// ...\nconst SUPABASE_SERVICE_ROLE_SCRET = process.env.SUPABASE_SERVICE_ROLE_SCRET;\n\nconst client = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_SCRET, {\n  // ...Optionen\n});\n"})})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},79621:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>d});var t=s(58101);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);