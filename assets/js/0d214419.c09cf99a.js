"use strict";(self.webpackChunk_logto_docs=self.webpackChunk_logto_docs||[]).push([[53316],{49613:function(e,t,r){r.d(t,{Zo:function(){return l},kt:function(){return d}});var o=r(59496);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,o)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function a(e,t){if(null==e)return{};var r,o,n=function(e,t){if(null==e)return{};var r,o,n={},i=Object.keys(e);for(o=0;o<i.length;o++)r=i[o],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)r=i[o],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var c=o.createContext({}),u=function(e){var t=o.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},l=function(e){var t=u(e.components);return o.createElement(c.Provider,{value:t},e.children)},g={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var r=e.components,n=e.mdxType,i=e.originalType,c=e.parentName,l=a(e,["components","mdxType","originalType","parentName"]),p=u(r),d=n,h=p["".concat(c,".").concat(d)]||p[d]||g[d]||i;return r?o.createElement(h,s(s({ref:t},l),{},{components:r})):o.createElement(h,s({ref:t},l))}));function d(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=r.length,s=new Array(i);s[0]=p;var a={};for(var c in t)hasOwnProperty.call(t,c)&&(a[c]=t[c]);a.originalType=e,a.mdxType="string"==typeof e?e:n,s[1]=a;for(var u=2;u<i;u++)s[u]=r[u];return o.createElement.apply(null,s)}return o.createElement.apply(null,r)}p.displayName="MDXCreateElement"},69783:function(e,t,r){r.r(t),r.d(t,{assets:function(){return l},contentTitle:function(){return c},default:function(){return d},frontMatter:function(){return a},metadata:function(){return u},toc:function(){return g}});var o=r(665),n=r(40151),i=(r(59496),r(49613)),s=["components"],a={sidebar_label:"Securing Your Webhooks",sidebar_position:4},c="Securing Your Webhooks",u={unversionedId:"docs/recipes/webhooks/securing-your-webhooks",id:"version-1.x/docs/recipes/webhooks/securing-your-webhooks",title:"Securing Your Webhooks",description:"Added in v1.5.0",source:"@site/versioned_docs/version-1.x/docs/recipes/webhooks/securing-your-webhooks.md",sourceDirName:"docs/recipes/webhooks",slug:"/docs/recipes/webhooks/securing-your-webhooks",permalink:"/logto-docs/docs/recipes/webhooks/securing-your-webhooks",draft:!1,editUrl:"https://github.com/logto-io/docs/tree/master/versioned_docs/version-1.x/docs/recipes/webhooks/securing-your-webhooks.md",tags:[],version:"1.x",sidebarPosition:4,frontMatter:{sidebar_label:"Securing Your Webhooks",sidebar_position:4},sidebar:"docsSidebar",previous:{title:"Webhook Request",permalink:"/logto-docs/docs/recipes/webhooks/webhook-request"},next:{title:"\ud83d\udd10 Role-Based Access Control (RBAC)",permalink:"/logto-docs/docs/recipes/rbac/"}},l={},g=[{value:"Getting the signing key",id:"getting-the-signing-key",level:2},{value:"Verifying the signature",id:"verifying-the-signature",level:2}],p={toc:g};function d(e){var t=e.components,r=(0,n.Z)(e,s);return(0,i.kt)("wrapper",(0,o.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"securing-your-webhooks"},"Securing Your Webhooks"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Added in v1.5.0")),(0,i.kt)("p",null,"Once your server is ready to receive webhook requests, you may want to make sure that it can handle the requests securely. Logto generates a signature for each webhook request payload, which allows you to verify that the request comes from Logto."),(0,i.kt)("h2",{id:"getting-the-signing-key"},"Getting the signing key"),(0,i.kt)("p",null,"You'll need to get the signing key from ",(0,i.kt)("a",{parentName:"p",href:"/logto-docs/docs/recipes/webhooks/configure-webhooks-in-console#secure-webhook"},"the Admin Console")," to verify the signature."),(0,i.kt)("h2",{id:"verifying-the-signature"},"Verifying the signature"),(0,i.kt)("p",null,"Extract the signature from the ",(0,i.kt)("inlineCode",{parentName:"p"},"logto-signature-sha-256")," header of the webhook request."),(0,i.kt)("p",null,"After that, you should generate a signature using your signing key, and the webhook request body and ensure that the result matches the signature from Logto."),(0,i.kt)("p",null,"Logto uses an HMAC hex digest to compute the signature."),(0,i.kt)("p",null,"Here's an example of how to verify the signature in Node.js:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { createHmac } from 'node:crypto';\n\nexport const verify = (signingKey: string, rawBody: Buffer[], expectedSignature: string) => {\n  const hmac = createHmac('sha256', signingKey);\n  hmac.update(rawBody);\n  const signature = hmac.digest('hex');\n  return signature === expectedSignature;\n};\n")))}d.isMDXComponent=!0}}]);